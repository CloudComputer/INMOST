<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>INMOST: INMOST::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">INMOST
   </div>
   <div id="projectbrief">A toolkit for distributed mathematical modeling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>INMOST</b></li><li class="navelem"><a class="el" href="classINMOST_1_1Mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classINMOST_1_1Mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">INMOST::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for INMOST::Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classINMOST_1_1Mesh__inherit__graph.png" border="0" usemap="#INMOST_1_1Mesh_inherit__map" alt="Inheritance graph"/></div>
<map name="INMOST_1_1Mesh_inherit__map" id="INMOST_1_1Mesh_inherit__map">
<area shape="rect" id="node2" href="classINMOST_1_1TagManager.html" title="INMOST::TagManager" alt="" coords="5,5,156,32"/><area shape="rect" id="node3" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. " alt="" coords="180,5,304,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for INMOST::Mesh:</div>
<div class="dyncontent">
<div class="center"><img src="classINMOST_1_1Mesh__coll__graph.png" border="0" usemap="#INMOST_1_1Mesh_coll__map" alt="Collaboration graph"/></div>
<map name="INMOST_1_1Mesh_coll__map" id="INMOST_1_1Mesh_coll__map">
<area shape="rect" id="node2" href="classINMOST_1_1TagManager.html" title="INMOST::TagManager" alt="" coords="5,5,156,32"/><area shape="rect" id="node3" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. " alt="" coords="180,5,304,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1BulkComparator.html">BulkComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1BulkDFComparator.html">BulkDFComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1CentroidComparator.html">CentroidComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1GlobalIDComparator.html">GlobalIDComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1IerarhyComparator.html">IerarhyComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1IntegerComparator.html">IntegerComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1IntegerDFComparator.html">IntegerDFComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1RealComparator.html">RealComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh_1_1RealDFComparator.html">RealDFComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7c38597c1e6e3e963983df9259231a33"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>MeshState</b> { <b>Serial</b>, 
<b>Parallel</b>
 }</td></tr>
<tr class="separator:a7c38597c1e6e3e963983df9259231a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6188cbe799f92cbddf37e2ff1310489e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Action</b> { <b>AGhost</b>, 
<b>AMigrate</b>
 }</td></tr>
<tr class="separator:a6188cbe799f92cbddf37e2ff1310489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e305a71cac82ce87df7bfe9c8e807d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Prepare</b> { <b>UnknownSize</b>, 
<b>UnknownSource</b>
 }</td></tr>
<tr class="separator:a96e305a71cac82ce87df7bfe9c8e807d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9055f423fc6502c7e476ce1247904e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9055f423fc6502c7e476ce1247904e6"></a>
typedef chunk_array&lt; <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>, <br class="typebreak"/>
chunk_bits_empty &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>empty_container</b></td></tr>
<tr class="separator:ae9055f423fc6502c7e476ce1247904e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e9f6b0b8eea367c332c36320d4c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a8e9f6b0b8eea367c332c36320d4c02"></a>
typedef chunk_array&lt; <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>, <br class="typebreak"/>
chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>links_container</b></td></tr>
<tr class="separator:a7a8e9f6b0b8eea367c332c36320d4c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa5359ad0ee39a9a35ed7230d8bd3e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa5359ad0ee39a9a35ed7230d8bd3e1"></a>
typedef TagManager::sparse_sub_type&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_type</b></td></tr>
<tr class="separator:a7aa5359ad0ee39a9a35ed7230d8bd3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a6bf9c3b9ce9d446c891a23329ef1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a108a6bf9c3b9ce9d446c891a23329ef1"></a>
typedef <br class="typebreak"/>
<a class="el" href="structINMOST_1_1TagManager_1_1sparse__sub__record.html">TagManager::sparse_sub_record</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_rec</b></td></tr>
<tr class="separator:a108a6bf9c3b9ce9d446c891a23329ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32a7de3dbfafd84c6635212b20aecb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa32a7de3dbfafd84c6635212b20aecb7"></a>
typedef sparse_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>senum</b></td></tr>
<tr class="separator:aa32a7de3dbfafd84c6635212b20aecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b71cc969ef0d9f4e87e51febbfec3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06b71cc969ef0d9f4e87e51febbfec3b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>ReduceOperation</b> )(const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, const <a class="el" href="classINMOST_1_1Element.html">Element</a> &amp;element, const INMOST_DATA_BULK_TYPE *recv_data, INMOST_DATA_ENUM_TYPE recv_size)</td></tr>
<tr class="separator:a06b71cc969ef0d9f4e87e51febbfec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e96c6c49203571ef3f391a5e65f5de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10e96c6c49203571ef3f391a5e65f5de"></a>
typedef std::vector&lt; <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tag_set</b></td></tr>
<tr class="separator:a10e96c6c49203571ef3f391a5e65f5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d97c93d9d3a7bee03180d5cd4372696"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d97c93d9d3a7bee03180d5cd4372696"></a>
typedef std::vector&lt; HandleType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>element_set</b></td></tr>
<tr class="separator:a2d97c93d9d3a7bee03180d5cd4372696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956b5292142d9a206f47a00d3f55b22f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a956b5292142d9a206f47a00d3f55b22f"></a>
typedef std::vector<br class="typebreak"/>
&lt; INMOST_DATA_BULK_TYPE &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_type</b></td></tr>
<tr class="separator:a956b5292142d9a206f47a00d3f55b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ae9912a7097744db789754a90118d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ae9912a7097744db789754a90118d5"></a>
typedef std::map&lt; int, <br class="typebreak"/>
element_set &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>proc_elements</b></td></tr>
<tr class="separator:ac6ae9912a7097744db789754a90118d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad396ce459946a34ebd8cc5e564ff7e20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad396ce459946a34ebd8cc5e564ff7e20"></a>
typedef std::pair&lt; int, <br class="typebreak"/>
buffer_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>proc_buffer_type</b></td></tr>
<tr class="separator:ad396ce459946a34ebd8cc5e564ff7e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdffb8a47775004fd0b7497d321405c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cdffb8a47775004fd0b7497d321405c"></a>
typedef std::vector<br class="typebreak"/>
&lt; proc_buffer_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>exch_buffer_type</b></td></tr>
<tr class="separator:a9cdffb8a47775004fd0b7497d321405c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3a085d38c3b8b12d708afef270bca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d3a085d38c3b8b12d708afef270bca9"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorStorage</b></td></tr>
<tr class="separator:a4d3a085d38c3b8b12d708afef270bca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f367f5aa2b0d86940e52a8a93b17e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37f367f5aa2b0d86940e52a8a93b17e0"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Element.html">Element</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorElement</b></td></tr>
<tr class="separator:a37f367f5aa2b0d86940e52a8a93b17e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a8ae93bb4bbfb4d9ca36b2f324ca00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29a8ae93bb4bbfb4d9ca36b2f324ca00"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorSet</b></td></tr>
<tr class="separator:a29a8ae93bb4bbfb4d9ca36b2f324ca00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808ade85adce097c826e100527391b1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a808ade85adce097c826e100527391b1d"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorCell</b></td></tr>
<tr class="separator:a808ade85adce097c826e100527391b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b0ec48bb09310671f2cb9fed44d8d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72b0ec48bb09310671f2cb9fed44d8d4"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorFace</b></td></tr>
<tr class="separator:a72b0ec48bb09310671f2cb9fed44d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c66b43ab828c819ec65f660c93937f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3c66b43ab828c819ec65f660c93937f"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorEdge</b></td></tr>
<tr class="separator:ae3c66b43ab828c819ec65f660c93937f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972f183065ada503d896cd70d73e95b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a972f183065ada503d896cd70d73e95b2"></a>
typedef <a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">base_iterator</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorNode</b></td></tr>
<tr class="separator:a972f183065ada503d896cd70d73e95b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78adb312fbe274f7a7296f86398514d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab78adb312fbe274f7a7296f86398514d"></a>
typedef tiny_map<br class="typebreak"/>
&lt; GeometricData, ElementType, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GeomParam</b></td></tr>
<tr class="separator:ab78adb312fbe274f7a7296f86398514d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:adda9f59b50509dee56fa03697e1b4b02 inherit pub_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adda9f59b50509dee56fa03697e1b4b02"></a>
typedef tag_array_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iteratorTag</b></td></tr>
<tr class="separator:adda9f59b50509dee56fa03697e1b4b02 inherit pub_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classINMOST_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classINMOST_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classINMOST_1_1Storage.html">INMOST::Storage</a></td></tr>
<tr class="memitem:a853346784b4a5822a7fac54d8f10f805 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a853346784b4a5822a7fac54d8f10f805"></a>
typedef INMOST_DATA_REAL_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a></td></tr>
<tr class="memdesc:a853346784b4a5822a7fac54d8f10f805 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a> type for representing real values. <br/></td></tr>
<tr class="separator:a853346784b4a5822a7fac54d8f10f805 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec96942bc647417a801e2895b45964d2 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec96942bc647417a801e2895b45964d2"></a>
typedef INMOST_DATA_INTEGER_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a></td></tr>
<tr class="memdesc:aec96942bc647417a801e2895b45964d2 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a> type for representing integer values. <br/></td></tr>
<tr class="separator:aec96942bc647417a801e2895b45964d2 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae429556af77094077d212e0ac23c8cfc inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae429556af77094077d212e0ac23c8cfc"></a>
typedef INMOST_DATA_BULK_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a></td></tr>
<tr class="memdesc:ae429556af77094077d212e0ac23c8cfc inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a> type for representing one byte of abstact data. <br/></td></tr>
<tr class="separator:ae429556af77094077d212e0ac23c8cfc inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae333dfced6fa9cfde0c8e7dcf1b0cc2b inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae333dfced6fa9cfde0c8e7dcf1b0cc2b"></a>
typedef INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a></td></tr>
<tr class="memdesc:ae333dfced6fa9cfde0c8e7dcf1b0cc2b inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for representing unsigned integer values. <br/></td></tr>
<tr class="separator:ae333dfced6fa9cfde0c8e7dcf1b0cc2b inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8674802045ec170a3c9d0e3281545b54 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8674802045ec170a3c9d0e3281545b54"></a>
typedef HandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a></td></tr>
<tr class="memdesc:a8674802045ec170a3c9d0e3281545b54 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a> type for representing references to <a class="el" href="classINMOST_1_1Element.html">Element</a>. <br/></td></tr>
<tr class="separator:a8674802045ec170a3c9d0e3281545b54 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430e5358d435befb38169beef593527e inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a430e5358d435befb38169beef593527e"></a>
typedef shell&lt; <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a></td></tr>
<tr class="memdesc:a430e5358d435befb38169beef593527e inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a> type for representing arrays of real values. <br/></td></tr>
<tr class="separator:a430e5358d435befb38169beef593527e inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1637367f0487eb778894b57fc94647 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1637367f0487eb778894b57fc94647"></a>
typedef shell&lt; <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a></td></tr>
<tr class="memdesc:a4d1637367f0487eb778894b57fc94647 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a> type for representing arrays of integer values. <br/></td></tr>
<tr class="separator:a4d1637367f0487eb778894b57fc94647 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e49b2a38cb55dd59529bd23e8b1b852 inherit pub_types_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e49b2a38cb55dd59529bd23e8b1b852"></a>
typedef shell&lt; <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a></td></tr>
<tr class="memdesc:a6e49b2a38cb55dd59529bd23e8b1b852 inherit pub_types_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a> type for representing abstact data as a series of bytes. <br/></td></tr>
<tr class="separator:a6e49b2a38cb55dd59529bd23e8b1b852 inherit pub_types_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99d2f7410acff5bc75b0184890d7decd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99d2f7410acff5bc75b0184890d7decd"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a99d2f7410acff5bc75b0184890d7decd">HandleDataPos</a> (HandleType h)</td></tr>
<tr class="memdesc:a99d2f7410acff5bc75b0184890d7decd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For debug purposes. <br/></td></tr>
<tr class="separator:a99d2f7410acff5bc75b0184890d7decd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7cbbd5950153b3c16e26f1bd50c3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2d7cbbd5950153b3c16e26f1bd50c3d"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab2d7cbbd5950153b3c16e26f1bd50c3d">MemoryUsage</a> (HandleType h)</td></tr>
<tr class="memdesc:ab2d7cbbd5950153b3c16e26f1bd50c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For parmetis return total number in bytes of occupied memory by element and its data. <br/></td></tr>
<tr class="separator:ab2d7cbbd5950153b3c16e26f1bd50c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef026100f4ec3b0165a5816558faadc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef026100f4ec3b0165a5816558faadc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (const <a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> &amp;other)</td></tr>
<tr class="separator:aef026100f4ec3b0165a5816558faadc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cc916a08f462721b5986abf71005ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83cc916a08f462721b5986abf71005ea"></a>
<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> const &amp;other)</td></tr>
<tr class="separator:a83cc916a08f462721b5986abf71005ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d860dda768f1d8b7a1b5cd2066cb504"><td class="memItemLeft" align="right" valign="top">MarkerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3d860dda768f1d8b7a1b5cd2066cb504">CreateMarker</a> ()</td></tr>
<tr class="memdesc:a3d860dda768f1d8b7a1b5cd2066cb504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new marker.  <a href="#a3d860dda768f1d8b7a1b5cd2066cb504">More...</a><br/></td></tr>
<tr class="separator:a3d860dda768f1d8b7a1b5cd2066cb504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0872520e92d5fefcb827b239d23e4229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0872520e92d5fefcb827b239d23e4229">ReleaseMarker</a> (MarkerType n)</td></tr>
<tr class="memdesc:a0872520e92d5fefcb827b239d23e4229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release marker back for reuse.  <a href="#a0872520e92d5fefcb827b239d23e4229">More...</a><br/></td></tr>
<tr class="separator:a0872520e92d5fefcb827b239d23e4229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef41098a12fe80cac6f45ee94ef892b"><td class="memItemLeft" align="right" valign="top">__INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8ef41098a12fe80cac6f45ee94ef892b">SetEpsilon</a> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> e)</td></tr>
<tr class="memdesc:a8ef41098a12fe80cac6f45ee94ef892b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tolerance for coordinates comparison.  <a href="#a8ef41098a12fe80cac6f45ee94ef892b">More...</a><br/></td></tr>
<tr class="separator:a8ef41098a12fe80cac6f45ee94ef892b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3651c7afd0489bd19eb83554b63d3a31"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3651c7afd0489bd19eb83554b63d3a31">GetEpsilon</a> () const </td></tr>
<tr class="memdesc:a3651c7afd0489bd19eb83554b63d3a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve tolerance for coordinates comparison.  <a href="#a3651c7afd0489bd19eb83554b63d3a31">More...</a><br/></td></tr>
<tr class="separator:a3651c7afd0489bd19eb83554b63d3a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a2c4cb85d29a3f8bae803b013a52c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a04a2c4cb85d29a3f8bae803b013a52c9">SetDimensions</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> dim)</td></tr>
<tr class="memdesc:a04a2c4cb85d29a3f8bae803b013a52c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of dimensions for mesh.  <a href="#a04a2c4cb85d29a3f8bae803b013a52c9">More...</a><br/></td></tr>
<tr class="separator:a04a2c4cb85d29a3f8bae803b013a52c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b7567174f1da1fe8317eb8bb1fdc6c"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae7b7567174f1da1fe8317eb8bb1fdc6c">GetDimensions</a> () const </td></tr>
<tr class="memdesc:ae7b7567174f1da1fe8317eb8bb1fdc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of dimensions of mesh.  <a href="#ae7b7567174f1da1fe8317eb8bb1fdc6c">More...</a><br/></td></tr>
<tr class="separator:ae7b7567174f1da1fe8317eb8bb1fdc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f707f8ed964b9ff6e143a625e193823"><td class="memItemLeft" align="right" valign="top">__INLINE MeshState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8f707f8ed964b9ff6e143a625e193823">GetMeshState</a> () const </td></tr>
<tr class="memdesc:a8f707f8ed964b9ff6e143a625e193823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parallel state of the mesh.  <a href="#a8f707f8ed964b9ff6e143a625e193823">More...</a><br/></td></tr>
<tr class="separator:a8f707f8ed964b9ff6e143a625e193823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b425c08bb3751726402817023c52aef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b425c08bb3751726402817023c52aef"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalIDTag</b> () const </td></tr>
<tr class="separator:a6b425c08bb3751726402817023c52aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36bf499bff23152a29d2b8bb579c2c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa36bf499bff23152a29d2b8bb579c2c3"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>CoordsTag</b> () const </td></tr>
<tr class="separator:aa36bf499bff23152a29d2b8bb579c2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5dd3ca51b3fa7163755edf1f3b5e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31c5dd3ca51b3fa7163755edf1f3b5e8"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>LowConnTag</b> () const </td></tr>
<tr class="separator:a31c5dd3ca51b3fa7163755edf1f3b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a9739ed3e0b585dfc814f09a2eaa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a722a9739ed3e0b585dfc814f09a2eaa9"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>HighConnTag</b> () const </td></tr>
<tr class="separator:a722a9739ed3e0b585dfc814f09a2eaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d9049c7e0f028e334d3fac70acdc6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7d9049c7e0f028e334d3fac70acdc6c"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MarkersTag</b> () const </td></tr>
<tr class="separator:ad7d9049c7e0f028e334d3fac70acdc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b33932803424957939cc2d245ba6f6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b33932803424957939cc2d245ba6f6f"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GeomTypeTag</b> () const </td></tr>
<tr class="separator:a2b33932803424957939cc2d245ba6f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f849b01ef5ebe06d7ef6bb425445bf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f849b01ef5ebe06d7ef6bb425445bf9"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SendtoTag</b> () const </td></tr>
<tr class="separator:a1f849b01ef5ebe06d7ef6bb425445bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f64ee311bb980ea6ec98a62d8c107c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12f64ee311bb980ea6ec98a62d8c107c"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SharedTag</b> () const </td></tr>
<tr class="separator:a12f64ee311bb980ea6ec98a62d8c107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc73de1636fffc74052b7b8c94cfcb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc73de1636fffc74052b7b8c94cfcb6"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>OwnerTag</b> () const </td></tr>
<tr class="separator:a8dc73de1636fffc74052b7b8c94cfcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f6d16015c510467e6b2fc53cbc25f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d3f6d16015c510467e6b2fc53cbc25f"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>LayersTag</b> () const </td></tr>
<tr class="separator:a1d3f6d16015c510467e6b2fc53cbc25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c676f8de7d824126800aac9728e54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9c676f8de7d824126800aac9728e54"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>BridgeTag</b> () const </td></tr>
<tr class="separator:aca9c676f8de7d824126800aac9728e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9cef94caadde4eb8ea34c73dbab03a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f9cef94caadde4eb8ea34c73dbab03a"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessorsTag</b> () const </td></tr>
<tr class="separator:a1f9cef94caadde4eb8ea34c73dbab03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ed5e05176a8fc0478a5c515c72aa8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6ed5e05176a8fc0478a5c515c72aa8a"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SetNameTag</b> () const </td></tr>
<tr class="separator:ae6ed5e05176a8fc0478a5c515c72aa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b52915cd79134141685f994f5364767"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b52915cd79134141685f994f5364767"></a>
__INLINE const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SetComparatorTag</b> () const </td></tr>
<tr class="separator:a5b52915cd79134141685f994f5364767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd4e1b35b122a5cfc24d6d74229b81b"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1cd4e1b35b122a5cfc24d6d74229b81b">RedistributeTag</a> ()</td></tr>
<tr class="memdesc:a1cd4e1b35b122a5cfc24d6d74229b81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't put this shortcut to any function directly, as it creates tag inside assign to other object of type <a class="el" href="classINMOST_1_1Tag.html">Tag</a> and put this object to functions.  <a href="#a1cd4e1b35b122a5cfc24d6d74229b81b">More...</a><br/></td></tr>
<tr class="separator:a1cd4e1b35b122a5cfc24d6d74229b81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d7bfbdaa069199d3f8b3c3e9e7f151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a02d7bfbdaa069199d3f8b3c3e9e7f151">CreateTag</a> (std::string name, DataType dtype, ElementType etype, ElementType sparse, INMOST_DATA_ENUM_TYPE size=ENUMUNDEF)</td></tr>
<tr class="memdesc:a02d7bfbdaa069199d3f8b3c3e9e7f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the tag by name, type and size.  <a href="#a02d7bfbdaa069199d3f8b3c3e9e7f151">More...</a><br/></td></tr>
<tr class="separator:a02d7bfbdaa069199d3f8b3c3e9e7f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43e132d6fd14903e263f00fbcffec51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae43e132d6fd14903e263f00fbcffec51">DeleteTag</a> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> tag, ElementType mask=NODE|EDGE|FACE|CELL|ESET|MESH)</td></tr>
<tr class="memdesc:ae43e132d6fd14903e263f00fbcffec51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the data that is represented by the tag from elements of selected type.  <a href="#ae43e132d6fd14903e263f00fbcffec51">More...</a><br/></td></tr>
<tr class="separator:ae43e132d6fd14903e263f00fbcffec51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2922f80c6c522500a887fe115cf5271d"><td class="memItemLeft" align="right" valign="top">__INLINE iteratorTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2922f80c6c522500a887fe115cf5271d">BeginTag</a> ()</td></tr>
<tr class="memdesc:a2922f80c6c522500a887fe115cf5271d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first tag defined on the mesh.  <a href="#a2922f80c6c522500a887fe115cf5271d">More...</a><br/></td></tr>
<tr class="separator:a2922f80c6c522500a887fe115cf5271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05939bf3f29697b1ffb2005a617ee585"><td class="memItemLeft" align="right" valign="top">__INLINE <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a05939bf3f29697b1ffb2005a617ee585">NumberOfTags</a> () const </td></tr>
<tr class="memdesc:a05939bf3f29697b1ffb2005a617ee585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the total number of valid tags.  <a href="#a05939bf3f29697b1ffb2005a617ee585">More...</a><br/></td></tr>
<tr class="separator:a05939bf3f29697b1ffb2005a617ee585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69466c97ab50182ba143df2a76d5d9f"><td class="memItemLeft" align="right" valign="top">__INLINE iteratorTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae69466c97ab50182ba143df2a76d5d9f">EndTag</a> ()</td></tr>
<tr class="memdesc:ae69466c97ab50182ba143df2a76d5d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indicator for loop to end iteration over tags.  <a href="#ae69466c97ab50182ba143df2a76d5d9f">More...</a><br/></td></tr>
<tr class="separator:ae69466c97ab50182ba143df2a76d5d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edad518a07d8d9cfadf7803553a4991"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2edad518a07d8d9cfadf7803553a4991">CreateNode</a> (const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *coords)</td></tr>
<tr class="memdesc:a2edad518a07d8d9cfadf7803553a4991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create node by given coordinates.  <a href="#a2edad518a07d8d9cfadf7803553a4991">More...</a><br/></td></tr>
<tr class="separator:a2edad518a07d8d9cfadf7803553a4991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b50ae7b0deede13ab3425cd6547943"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3b50ae7b0deede13ab3425cd6547943"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateEdge</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:ae3b50ae7b0deede13ab3425cd6547943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709a5702c9f1dca9247ddf3efc23f411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a709a5702c9f1dca9247ddf3efc23f411"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFace</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Edge.html">Edge</a> &gt; &amp;edges)</td></tr>
<tr class="separator:a709a5702c9f1dca9247ddf3efc23f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e8a84e80ee682db190ee94302d8eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae71e8a84e80ee682db190ee94302d8eb"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateFace</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:ae71e8a84e80ee682db190ee94302d8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66260da2a0bf10c3d4876dea49dfbd58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66260da2a0bf10c3d4876dea49dfbd58"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateCell</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt; &amp;faces, const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;suggest_nodes_order=<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;(NULL))</td></tr>
<tr class="separator:a66260da2a0bf10c3d4876dea49dfbd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f493557835c8b2f571cf2af98b1c38f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f493557835c8b2f571cf2af98b1c38f"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateCell</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;c_f_nodes, const <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *c_f_numnodes, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> num_c_faces, const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;suggest_nodes_order=<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;(NULL))</td></tr>
<tr class="separator:a8f493557835c8b2f571cf2af98b1c38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0ca2ce40dfebddd57f006643477234"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a0ca2ce40dfebddd57f006643477234"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateCell</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;c_nodes, const <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *c_f_nodeinds, const <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> *c_f_numnodes, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> num_c_faces, const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;suggest_nodes_order=<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt;(NULL))</td></tr>
<tr class="separator:a5a0ca2ce40dfebddd57f006643477234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c27ec28c027eaf82475a35ab97b0ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c27ec28c027eaf82475a35ab97b0ad"></a>
std::pair&lt; <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateSet</b> (std::string name)</td></tr>
<tr class="separator:a13c27ec28c027eaf82475a35ab97b0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5223aa8af17d63c7be40027ff789df7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5223aa8af17d63c7be40027ff789df7e">GetSet</a> (std::string name)</td></tr>
<tr class="memdesc:a5223aa8af17d63c7be40027ff789df7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve set by name.  <a href="#a5223aa8af17d63c7be40027ff789df7e">More...</a><br/></td></tr>
<tr class="separator:a5223aa8af17d63c7be40027ff789df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031ce76512ea59b68cad89aca64b8da7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a031ce76512ea59b68cad89aca64b8da7"></a>
<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a031ce76512ea59b68cad89aca64b8da7">GetSetsByPrefix</a> (std::string prefix)</td></tr>
<tr class="memdesc:a031ce76512ea59b68cad89aca64b8da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the sets whose names start with given prefix. <br/></td></tr>
<tr class="separator:a031ce76512ea59b68cad89aca64b8da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e00078afcbee494f8e4c02d1e088203"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e00078afcbee494f8e4c02d1e088203"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>LastCreated</b> () const </td></tr>
<tr class="separator:a9e00078afcbee494f8e4c02d1e088203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab446c474d012ad8a16e82cf8b297d084"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab446c474d012ad8a16e82cf8b297d084"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidHandleRange</b> (HandleType h) const </td></tr>
<tr class="separator:ab446c474d012ad8a16e82cf8b297d084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05701da4bd3ed8ca69bbcca256c2b0e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05701da4bd3ed8ca69bbcca256c2b0e2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidElement</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> etypenum, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:a05701da4bd3ed8ca69bbcca256c2b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6fa04f985b48852a2fd6305364983e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6fa04f985b48852a2fd6305364983e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidElement</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:aed6fa04f985b48852a2fd6305364983e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe80cb31b7763f7124d013050c21e3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefe80cb31b7763f7124d013050c21e3e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidElement</b> (HandleType h) const </td></tr>
<tr class="separator:aefe80cb31b7763f7124d013050c21e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116f510afe89689b615fa73b29bc6f59"><td class="memItemLeft" align="right" valign="top">HandleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a116f510afe89689b615fa73b29bc6f59">FindSharedAdjacency</a> (const HandleType *arr, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num) const </td></tr>
<tr class="memdesc:a116f510afe89689b615fa73b29bc6f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve upper adjacent that is shared by multiple lower adjacencies.  <a href="#a116f510afe89689b615fa73b29bc6f59">More...</a><br/></td></tr>
<tr class="separator:a116f510afe89689b615fa73b29bc6f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5191aea52d0cb3b8719500bc98d72df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5191aea52d0cb3b8719500bc98d72df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReorderEmpty</b> (ElementType reordertypes)</td></tr>
<tr class="separator:ae5191aea52d0cb3b8719500bc98d72df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1b5232061e8f615d962c55dc5397c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc1b5232061e8f615d962c55dc5397c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReorderApply</b> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> index, ElementType mask)</td></tr>
<tr class="separator:acc1b5232061e8f615d962c55dc5397c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e1126542b6778477ec51bf61dd35d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73e1126542b6778477ec51bf61dd35d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RestoreCellNodes</b> (HandleType hc, <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Node.html">Node</a> &gt; &amp;ret)</td></tr>
<tr class="separator:a73e1126542b6778477ec51bf61dd35d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa084c637bc9f6850ed77fbb7778d404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#afa084c637bc9f6850ed77fbb7778d404">Real</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:afa084c637bc9f6850ed77fbb7778d404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of real values.  <a href="#afa084c637bc9f6850ed77fbb7778d404">More...</a><br/></td></tr>
<tr class="separator:afa084c637bc9f6850ed77fbb7778d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d44832b3e826a2b61c8e91c5457fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa9d44832b3e826a2b61c8e91c5457fbf">Integer</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:aa9d44832b3e826a2b61c8e91c5457fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of integer values.  <a href="#aa9d44832b3e826a2b61c8e91c5457fbf">More...</a><br/></td></tr>
<tr class="separator:aa9d44832b3e826a2b61c8e91c5457fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df5a8793e5cd8e38182de107d381d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9df5a8793e5cd8e38182de107d381d9e">Bulk</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a9df5a8793e5cd8e38182de107d381d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in inner representation to the first element of array of bytes.  <a href="#a9df5a8793e5cd8e38182de107d381d9e">More...</a><br/></td></tr>
<tr class="separator:a9df5a8793e5cd8e38182de107d381d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa8b2f65d63edbbed90d865ab6f5314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#acfa8b2f65d63edbbed90d865ab6f5314">Reference</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:acfa8b2f65d63edbbed90d865ab6f5314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in inner representation to the first element of array of element handles.  <a href="#acfa8b2f65d63edbbed90d865ab6f5314">More...</a><br/></td></tr>
<tr class="separator:acfa8b2f65d63edbbed90d865ab6f5314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bdd4e7c0d26750ca0aa40e03fc7d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a06bdd4e7c0d26750ca0aa40e03fc7d4c">RealArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a06bdd4e7c0d26750ca0aa40e03fc7d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of real values.  <a href="#a06bdd4e7c0d26750ca0aa40e03fc7d4c">More...</a><br/></td></tr>
<tr class="separator:a06bdd4e7c0d26750ca0aa40e03fc7d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bbbfafae1405bd27b726bdbb4c2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac0bbbfafae1405bd27b726bdbb4c2cdd">IntegerArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ac0bbbfafae1405bd27b726bdbb4c2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of integer values.  <a href="#ac0bbbfafae1405bd27b726bdbb4c2cdd">More...</a><br/></td></tr>
<tr class="separator:ac0bbbfafae1405bd27b726bdbb4c2cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae496bab413c4a6103ee62ae3903e95fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae496bab413c4a6103ee62ae3903e95fe">BulkArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ae496bab413c4a6103ee62ae3903e95fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of bytes.  <a href="#ae496bab413c4a6103ee62ae3903e95fe">More...</a><br/></td></tr>
<tr class="separator:ae496bab413c4a6103ee62ae3903e95fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211da4cbe1dc33394c9b725b64b1e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac211da4cbe1dc33394c9b725b64b1e86">ReferenceArray</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ac211da4cbe1dc33394c9b725b64b1e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element handles.  <a href="#ac211da4cbe1dc33394c9b725b64b1e86">More...</a><br/></td></tr>
<tr class="separator:ac211da4cbe1dc33394c9b725b64b1e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e88bbdedcf71c3226f3dc94da66807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a90e88bbdedcf71c3226f3dc94da66807">RealDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a90e88bbdedcf71c3226f3dc94da66807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of real values.  <a href="#a90e88bbdedcf71c3226f3dc94da66807">More...</a><br/></td></tr>
<tr class="separator:a90e88bbdedcf71c3226f3dc94da66807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd3068d4db02871478bea86fce38945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3dd3068d4db02871478bea86fce38945">IntegerDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a3dd3068d4db02871478bea86fce38945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to inner memory location of the first element of the array of integer values.  <a href="#a3dd3068d4db02871478bea86fce38945">More...</a><br/></td></tr>
<tr class="separator:a3dd3068d4db02871478bea86fce38945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88229181252531147051badf5a05e263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a88229181252531147051badf5a05e263">BulkDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a88229181252531147051badf5a05e263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of constant size array of bytes.  <a href="#a88229181252531147051badf5a05e263">More...</a><br/></td></tr>
<tr class="separator:a88229181252531147051badf5a05e263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5abf1a33ab21a0c60338a97287fc115"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab5abf1a33ab21a0c60338a97287fc115">ReferenceDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ab5abf1a33ab21a0c60338a97287fc115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of constant size array of element handles.  <a href="#ab5abf1a33ab21a0c60338a97287fc115">More...</a><br/></td></tr>
<tr class="separator:ab5abf1a33ab21a0c60338a97287fc115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527fa3c2f6ece108b5abce389566365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8527fa3c2f6ece108b5abce389566365">RealArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a8527fa3c2f6ece108b5abce389566365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of real values in dense array.  <a href="#a8527fa3c2f6ece108b5abce389566365">More...</a><br/></td></tr>
<tr class="separator:a8527fa3c2f6ece108b5abce389566365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5351b2b6e7f7824598cb46b3c35118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9d5351b2b6e7f7824598cb46b3c35118">IntegerArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a9d5351b2b6e7f7824598cb46b3c35118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of integer values in dense array.  <a href="#a9d5351b2b6e7f7824598cb46b3c35118">More...</a><br/></td></tr>
<tr class="separator:a9d5351b2b6e7f7824598cb46b3c35118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d63f6a251db48695306180f22ff67e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a53d63f6a251db48695306180f22ff67e">BulkArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a53d63f6a251db48695306180f22ff67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of bytes in dense array.  <a href="#a53d63f6a251db48695306180f22ff67e">More...</a><br/></td></tr>
<tr class="separator:a53d63f6a251db48695306180f22ff67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba4c935940111e2c9584a9cc96fe6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a92ba4c935940111e2c9584a9cc96fe6f">ReferenceArrayDF</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a92ba4c935940111e2c9584a9cc96fe6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element handles in dense array.  <a href="#a92ba4c935940111e2c9584a9cc96fe6f">More...</a><br/></td></tr>
<tr class="separator:a92ba4c935940111e2c9584a9cc96fe6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679a4a6ed4e4508126919b8fc8fea27a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a679a4a6ed4e4508126919b8fc8fea27a">RealDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a679a4a6ed4e4508126919b8fc8fea27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of real values.  <a href="#a679a4a6ed4e4508126919b8fc8fea27a">More...</a><br/></td></tr>
<tr class="separator:a679a4a6ed4e4508126919b8fc8fea27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20ebec0bab305054c5960d7683bfcfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#af20ebec0bab305054c5960d7683bfcfd">IntegerDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:af20ebec0bab305054c5960d7683bfcfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of integer values.  <a href="#af20ebec0bab305054c5960d7683bfcfd">More...</a><br/></td></tr>
<tr class="separator:af20ebec0bab305054c5960d7683bfcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a62a1c63ac51297dddabb1312f32d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a35a62a1c63ac51297dddabb1312f32d1">BulkDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a35a62a1c63ac51297dddabb1312f32d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of bytes.  <a href="#a35a62a1c63ac51297dddabb1312f32d1">More...</a><br/></td></tr>
<tr class="separator:a35a62a1c63ac51297dddabb1312f32d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87430b220565362949e68b073e07c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac87430b220565362949e68b073e07c8a">ReferenceDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ac87430b220565362949e68b073e07c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference in dense array to the first element of variable size array of element handles.  <a href="#ac87430b220565362949e68b073e07c8a">More...</a><br/></td></tr>
<tr class="separator:ac87430b220565362949e68b073e07c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a5f7d22e5b9f7c01b9741719b853dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae7a5f7d22e5b9f7c01b9741719b853dc">RealArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ae7a5f7d22e5b9f7c01b9741719b853dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of real values in dense array of variable size.  <a href="#ae7a5f7d22e5b9f7c01b9741719b853dc">More...</a><br/></td></tr>
<tr class="separator:ae7a5f7d22e5b9f7c01b9741719b853dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74aed700689551567039dfddfbf5971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ad74aed700689551567039dfddfbf5971">IntegerArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:ad74aed700689551567039dfddfbf5971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of integer values in dense array of variable size.  <a href="#ad74aed700689551567039dfddfbf5971">More...</a><br/></td></tr>
<tr class="separator:ad74aed700689551567039dfddfbf5971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042974abc70e48b9dc84714ca1a50655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a042974abc70e48b9dc84714ca1a50655">BulkArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a042974abc70e48b9dc84714ca1a50655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of bytes in dense array of variable size.  <a href="#a042974abc70e48b9dc84714ca1a50655">More...</a><br/></td></tr>
<tr class="separator:a042974abc70e48b9dc84714ca1a50655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a8c6f6d53a863be14b2c137de4eff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa2a8c6f6d53a863be14b2c137de4eff5">ReferenceArrayDV</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:aa2a8c6f6d53a863be14b2c137de4eff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of element handles in dense array of variable size.  <a href="#aa2a8c6f6d53a863be14b2c137de4eff5">More...</a><br/></td></tr>
<tr class="separator:aa2a8c6f6d53a863be14b2c137de4eff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eb79ff655477197ce21dedae4712d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab0eb79ff655477197ce21dedae4712d4">SetMarker</a> (HandleType h, MarkerType n)</td></tr>
<tr class="memdesc:ab0eb79ff655477197ce21dedae4712d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a marker on the element represented by handle.  <a href="#ab0eb79ff655477197ce21dedae4712d4">More...</a><br/></td></tr>
<tr class="separator:ab0eb79ff655477197ce21dedae4712d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ff5329978e77876ca6b1b3ed9b5c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a84ff5329978e77876ca6b1b3ed9b5c39">SetMarkerArray</a> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> n, MarkerType m)</td></tr>
<tr class="memdesc:a84ff5329978e77876ca6b1b3ed9b5c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a marker on the set of handles.  <a href="#a84ff5329978e77876ca6b1b3ed9b5c39">More...</a><br/></td></tr>
<tr class="separator:a84ff5329978e77876ca6b1b3ed9b5c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8a00522e2b06a0b59e25cae119a237"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2c8a00522e2b06a0b59e25cae119a237">GetMarker</a> (HandleType h, MarkerType n) const </td></tr>
<tr class="memdesc:a2c8a00522e2b06a0b59e25cae119a237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check weather the marker is set one the element.  <a href="#a2c8a00522e2b06a0b59e25cae119a237">More...</a><br/></td></tr>
<tr class="separator:a2c8a00522e2b06a0b59e25cae119a237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa758ff129bf79eff3c446946e276006c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa758ff129bf79eff3c446946e276006c">RemMarker</a> (HandleType h, MarkerType n)</td></tr>
<tr class="memdesc:aa758ff129bf79eff3c446946e276006c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the marker from the element.  <a href="#aa758ff129bf79eff3c446946e276006c">More...</a><br/></td></tr>
<tr class="separator:aa758ff129bf79eff3c446946e276006c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f8614996be1f7dd81825a447e9f4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a14f8614996be1f7dd81825a447e9f4e8">RemMarkerArray</a> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> n, MarkerType m)</td></tr>
<tr class="memdesc:a14f8614996be1f7dd81825a447e9f4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the marker from the set of handles.  <a href="#a14f8614996be1f7dd81825a447e9f4e8">More...</a><br/></td></tr>
<tr class="separator:a14f8614996be1f7dd81825a447e9f4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b688c3af40eeef80d7d365c56be193f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b688c3af40eeef80d7d365c56be193f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a4b688c3af40eeef80d7d365c56be193f">ClearMarkerSpace</a> (HandleType h)</td></tr>
<tr class="memdesc:a4b688c3af40eeef80d7d365c56be193f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the markers from the element. <br/></td></tr>
<tr class="separator:a4b688c3af40eeef80d7d365c56be193f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7db80997803b96df82f83c4e53f64ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab7db80997803b96df82f83c4e53f64ec">GetMarkerSpace</a> (HandleType h, <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> copy[MarkerFields]) const </td></tr>
<tr class="memdesc:ab7db80997803b96df82f83c4e53f64ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the bytes that store markers on the element.  <a href="#ab7db80997803b96df82f83c4e53f64ec">More...</a><br/></td></tr>
<tr class="separator:ab7db80997803b96df82f83c4e53f64ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcd74b16a7a86db78d2cf5bb814f5a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aadcd74b16a7a86db78d2cf5bb814f5a3">SetMarkerSpace</a> (HandleType h, <a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> source[MarkerFields])</td></tr>
<tr class="memdesc:aadcd74b16a7a86db78d2cf5bb814f5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite the bytes that store markers on the element.  <a href="#aadcd74b16a7a86db78d2cf5bb814f5a3">More...</a><br/></td></tr>
<tr class="separator:aadcd74b16a7a86db78d2cf5bb814f5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7462d775868bb6ef687cef8a5198cb"><td class="memItemLeft" align="right" valign="top">Element::adj_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1e7462d775868bb6ef687cef8a5198cb">HighConn</a> (HandleType h)</td></tr>
<tr class="memdesc:a1e7462d775868bb6ef687cef8a5198cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly higher order adjacencies of current element with right of modification.  <a href="#a1e7462d775868bb6ef687cef8a5198cb">More...</a><br/></td></tr>
<tr class="separator:a1e7462d775868bb6ef687cef8a5198cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6728d9a7247c3a1b566fa127785318f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6728d9a7247c3a1b566fa127785318f7"></a>
Element::adj_type const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a6728d9a7247c3a1b566fa127785318f7">HighConn</a> (HandleType h) const </td></tr>
<tr class="memdesc:a6728d9a7247c3a1b566fa127785318f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly higher order adjacencies of current element without right of modification. <br/></td></tr>
<tr class="separator:a6728d9a7247c3a1b566fa127785318f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20f64a301adf9c3fafe28a8f921a791"><td class="memItemLeft" align="right" valign="top">Element::adj_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ad20f64a301adf9c3fafe28a8f921a791">LowConn</a> (HandleType h)</td></tr>
<tr class="memdesc:ad20f64a301adf9c3fafe28a8f921a791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly lower order adjacencies of current element with right of modification.  <a href="#ad20f64a301adf9c3fafe28a8f921a791">More...</a><br/></td></tr>
<tr class="separator:ad20f64a301adf9c3fafe28a8f921a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f709414cd7ae4464b0e2af48a8e44e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7f709414cd7ae4464b0e2af48a8e44e"></a>
Element::adj_type const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab7f709414cd7ae4464b0e2af48a8e44e">LowConn</a> (HandleType h) const </td></tr>
<tr class="memdesc:ab7f709414cd7ae4464b0e2af48a8e44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access directly lower order adjacencies of current element without right of modification. <br/></td></tr>
<tr class="separator:ab7f709414cd7ae4464b0e2af48a8e44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a721e7a76dba9bc87c4f014bff013cc"><td class="memItemLeft" align="right" valign="top">INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a4a721e7a76dba9bc87c4f014bff013cc">GetDataSize</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a4a721e7a76dba9bc87c4f014bff013cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the array.  <a href="#a4a721e7a76dba9bc87c4f014bff013cc">More...</a><br/></td></tr>
<tr class="separator:a4a721e7a76dba9bc87c4f014bff013cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ade9beb68c97be47897b50ce6e4dcb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8ade9beb68c97be47897b50ce6e4dcb6">SetDataSize</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> new_size)</td></tr>
<tr class="memdesc:a8ade9beb68c97be47897b50ce6e4dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the array for data of variable size.  <a href="#a8ade9beb68c97be47897b50ce6e4dcb6">More...</a><br/></td></tr>
<tr class="separator:a8ade9beb68c97be47897b50ce6e4dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9c22bde076d9828752924f1b6cefb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#abd9c22bde076d9828752924f1b6cefb1">GetData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> shift, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, void *data) const </td></tr>
<tr class="memdesc:abd9c22bde076d9828752924f1b6cefb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy inner data array of size elements to provided array begining from shift element.  <a href="#abd9c22bde076d9828752924f1b6cefb1">More...</a><br/></td></tr>
<tr class="separator:abd9c22bde076d9828752924f1b6cefb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e40d1712147e6dc39113d855882743e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2e40d1712147e6dc39113d855882743e">SetData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> shift, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, const void *data)</td></tr>
<tr class="memdesc:a2e40d1712147e6dc39113d855882743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy into inner data array of size elements from provided array begining from shift element.  <a href="#a2e40d1712147e6dc39113d855882743e">More...</a><br/></td></tr>
<tr class="separator:a2e40d1712147e6dc39113d855882743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab20c754eef0006e3085dc546e893bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#afab20c754eef0006e3085dc546e893bb">DelData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:afab20c754eef0006e3085dc546e893bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove tag data from given element.  <a href="#afab20c754eef0006e3085dc546e893bb">More...</a><br/></td></tr>
<tr class="separator:afab20c754eef0006e3085dc546e893bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac72292a681f80f9f112566e3c04bc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#abac72292a681f80f9f112566e3c04bc5">DelDenseData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:abac72292a681f80f9f112566e3c04bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data of variable size, clears to zero data of fixed size.  <a href="#abac72292a681f80f9f112566e3c04bc5">More...</a><br/></td></tr>
<tr class="separator:abac72292a681f80f9f112566e3c04bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21517e19d638410e9a5bdbaf4cc8fd4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a21517e19d638410e9a5bdbaf4cc8fd4c">DelSparseData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag)</td></tr>
<tr class="memdesc:a21517e19d638410e9a5bdbaf4cc8fd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data of variable size and sparse tag data.  <a href="#a21517e19d638410e9a5bdbaf4cc8fd4c">More...</a><br/></td></tr>
<tr class="separator:a21517e19d638410e9a5bdbaf4cc8fd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fe30c96eba52f03de5780503116af1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a14fe30c96eba52f03de5780503116af1">HaveData</a> (HandleType h, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a14fe30c96eba52f03de5780503116af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether data is present on given element.  <a href="#a14fe30c96eba52f03de5780503116af1">More...</a><br/></td></tr>
<tr class="separator:a14fe30c96eba52f03de5780503116af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819feef3c5f1206d8bbc6775becc739e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a819feef3c5f1206d8bbc6775becc739e"></a>
Element::GeometricType&#160;</td><td class="memItemRight" valign="bottom"><b>GetGeometricType</b> (HandleType h) const </td></tr>
<tr class="separator:a819feef3c5f1206d8bbc6775becc739e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497dd8d40df1e33fd3040056a7922549"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a497dd8d40df1e33fd3040056a7922549"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetGeometricType</b> (HandleType h, Element::GeometricType type)</td></tr>
<tr class="separator:a497dd8d40df1e33fd3040056a7922549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f84a185381a0096fc358e7e2ff5db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab9f84a185381a0096fc358e7e2ff5db7">GlobalID</a> (HandleType h)</td></tr>
<tr class="memdesc:ab9f84a185381a0096fc358e7e2ff5db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve global id of the element with right of modification (dangerous to modify).  <a href="#ab9f84a185381a0096fc358e7e2ff5db7">More...</a><br/></td></tr>
<tr class="separator:ab9f84a185381a0096fc358e7e2ff5db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c43e6d9cb856c240f084b2f839c2c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1c43e6d9cb856c240f084b2f839c2c8c">GlobalID</a> (HandleType h) const </td></tr>
<tr class="memdesc:a1c43e6d9cb856c240f084b2f839c2c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve global id of the element without right of modification.  <a href="#a1c43e6d9cb856c240f084b2f839c2c8c">More...</a><br/></td></tr>
<tr class="separator:a1c43e6d9cb856c240f084b2f839c2c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2078f4c2589dc14fe6291416ac21050f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2078f4c2589dc14fe6291416ac21050f">DataLocalID</a> (HandleType h) const </td></tr>
<tr class="memdesc:a2078f4c2589dc14fe6291416ac21050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve position of the data position of current element.  <a href="#a2078f4c2589dc14fe6291416ac21050f">More...</a><br/></td></tr>
<tr class="separator:a2078f4c2589dc14fe6291416ac21050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94963a0f3f1d80ee0785fb8ebd409339"><td class="memItemLeft" align="right" valign="top">Element::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a94963a0f3f1d80ee0785fb8ebd409339">GetStatus</a> (HandleType h) const </td></tr>
<tr class="memdesc:a94963a0f3f1d80ee0785fb8ebd409339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve parallel status of the element.  <a href="#a94963a0f3f1d80ee0785fb8ebd409339">More...</a><br/></td></tr>
<tr class="separator:a94963a0f3f1d80ee0785fb8ebd409339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666201ee66a5a0f871d17781055b06ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a666201ee66a5a0f871d17781055b06ac">SetStatus</a> (HandleType h, Element::Status s)</td></tr>
<tr class="memdesc:a666201ee66a5a0f871d17781055b06ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parallel status of the element.  <a href="#a666201ee66a5a0f871d17781055b06ac">More...</a><br/></td></tr>
<tr class="separator:a666201ee66a5a0f871d17781055b06ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c090ee95e802c4f486a5d98fc6cb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0">Destroy</a> (HandleType h)</td></tr>
<tr class="memdesc:a0e2c090ee95e802c4f486a5d98fc6cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely destroy element from mesh.  <a href="#a0e2c090ee95e802c4f486a5d98fc6cb0">More...</a><br/></td></tr>
<tr class="separator:a0e2c090ee95e802c4f486a5d98fc6cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656d48f7478afdc5240295ad97929dab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a656d48f7478afdc5240295ad97929dab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a656d48f7478afdc5240295ad97929dab">Destroy</a> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;e)</td></tr>
<tr class="memdesc:a656d48f7478afdc5240295ad97929dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for typed elements. <br/></td></tr>
<tr class="separator:a656d48f7478afdc5240295ad97929dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3eaaadcd233cf11deba24d1fd64ad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1">Hide</a> (HandleType h)</td></tr>
<tr class="memdesc:a2b3eaaadcd233cf11deba24d1fd64ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide element from mesh.  <a href="#a2b3eaaadcd233cf11deba24d1fd64ad1">More...</a><br/></td></tr>
<tr class="separator:a2b3eaaadcd233cf11deba24d1fd64ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfe7b75e432280922bfa7293743115c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a3bfe7b75e432280922bfa7293743115c">Show</a> (HandleType h)</td></tr>
<tr class="memdesc:a3bfe7b75e432280922bfa7293743115c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show element from mesh.  <a href="#a3bfe7b75e432280922bfa7293743115c">More...</a><br/></td></tr>
<tr class="separator:a3bfe7b75e432280922bfa7293743115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569c516120df121980d0585deadd3634"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a569c516120df121980d0585deadd3634">Delete</a> (HandleType h)</td></tr>
<tr class="memdesc:a569c516120df121980d0585deadd3634"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will hide element in modification state (between BeginModification and EndModification) or call Destroy in non-modification state.  <a href="#a569c516120df121980d0585deadd3634">More...</a><br/></td></tr>
<tr class="separator:a569c516120df121980d0585deadd3634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632e8966cbebd2e82df1edc7474a5993"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a632e8966cbebd2e82df1edc7474a5993">Hidden</a> (HandleType h) const </td></tr>
<tr class="memdesc:a632e8966cbebd2e82df1edc7474a5993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether element is hidden.  <a href="#a632e8966cbebd2e82df1edc7474a5993">More...</a><br/></td></tr>
<tr class="separator:a632e8966cbebd2e82df1edc7474a5993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa34219e9c94a2509c7bae2254ea7a14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aaa34219e9c94a2509c7bae2254ea7a14">New</a> (HandleType h) const </td></tr>
<tr class="memdesc:aaa34219e9c94a2509c7bae2254ea7a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether element is new.  <a href="#aaa34219e9c94a2509c7bae2254ea7a14">More...</a><br/></td></tr>
<tr class="separator:aaa34219e9c94a2509c7bae2254ea7a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887f25126d7a0fc38e238e5c2b033d58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a887f25126d7a0fc38e238e5c2b033d58">ComputeGeometricType</a> (HandleType h)</td></tr>
<tr class="memdesc:a887f25126d7a0fc38e238e5c2b033d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recompute geometrical type of current element and set it to element.  <a href="#a887f25126d7a0fc38e238e5c2b033d58">More...</a><br/></td></tr>
<tr class="separator:a887f25126d7a0fc38e238e5c2b033d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09727abab2781d3fbbcff23ca064777b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09727abab2781d3fbbcff23ca064777b"></a>
INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a09727abab2781d3fbbcff23ca064777b">GetArrayCapacity</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> etypenum)</td></tr>
<tr class="memdesc:a09727abab2781d3fbbcff23ca064777b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is needed by <a class="el" href="classINMOST_1_1TagManager.html">TagManager</a>, may be made private in future follows definition of chunk_array to estimate current occupancy of arrays. <br/></td></tr>
<tr class="separator:a09727abab2781d3fbbcff23ca064777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc92ee8e1fc34b3f3a41f2a1984ab6f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#adc92ee8e1fc34b3f3a41f2a1984ab6f2">SetParallelStrategy</a> (int strategy)</td></tr>
<tr class="memdesc:adc92ee8e1fc34b3f3a41f2a1984ab6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parallel strategy for inner communications.  <a href="#adc92ee8e1fc34b3f3a41f2a1984ab6f2">More...</a><br/></td></tr>
<tr class="separator:adc92ee8e1fc34b3f3a41f2a1984ab6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8543798618f286ce2af5ca2d5a0d7b87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8543798618f286ce2af5ca2d5a0d7b87">GetParallelStrategy</a> ()</td></tr>
<tr class="memdesc:a8543798618f286ce2af5ca2d5a0d7b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve currently set parallel strategy.  <a href="#a8543798618f286ce2af5ca2d5a0d7b87">More...</a><br/></td></tr>
<tr class="separator:a8543798618f286ce2af5ca2d5a0d7b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e45b137719114d78119bfe487be259f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2e45b137719114d78119bfe487be259f">SetParallelFileStrategy</a> (int strategy)</td></tr>
<tr class="memdesc:a2e45b137719114d78119bfe487be259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This strategy correspond only to internal ".pmf" mesh format.  <a href="#a2e45b137719114d78119bfe487be259f">More...</a><br/></td></tr>
<tr class="separator:a2e45b137719114d78119bfe487be259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8d32b876d5299b4da51de0f5f5386a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a7a8d32b876d5299b4da51de0f5f5386a">GetParallelFileStrategy</a> ()</td></tr>
<tr class="memdesc:a7a8d32b876d5299b4da51de0f5f5386a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve currently set parallel strategy for ".pmf" files.  <a href="#a7a8d32b876d5299b4da51de0f5f5386a">More...</a><br/></td></tr>
<tr class="separator:a7a8d32b876d5299b4da51de0f5f5386a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e810a4aa1bebf48a9911304b3b5bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e810a4aa1bebf48a9911304b3b5bce"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a35e810a4aa1bebf48a9911304b3b5bce">GetProcessorRank</a> ()</td></tr>
<tr class="memdesc:a35e810a4aa1bebf48a9911304b3b5bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rank of current processor. <br/></td></tr>
<tr class="separator:a35e810a4aa1bebf48a9911304b3b5bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7400218ed56f607396affac271954f37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7400218ed56f607396affac271954f37"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a7400218ed56f607396affac271954f37">GetProcessorsNumber</a> ()</td></tr>
<tr class="memdesc:a7400218ed56f607396affac271954f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of processors. <br/></td></tr>
<tr class="separator:a7400218ed56f607396affac271954f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36b17a701ff34b531ebb81ca9c2a8cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae36b17a701ff34b531ebb81ca9c2a8cc"></a>
INMOST_MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae36b17a701ff34b531ebb81ca9c2a8cc">GetCommunicator</a> ()</td></tr>
<tr class="memdesc:ae36b17a701ff34b531ebb81ca9c2a8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve MPI communicator. <br/></td></tr>
<tr class="separator:ae36b17a701ff34b531ebb81ca9c2a8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60495d087cbd5c893c5322ba0fa2c69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab60495d087cbd5c893c5322ba0fa2c69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab60495d087cbd5c893c5322ba0fa2c69">SetCommunicator</a> (INMOST_MPI_Comm _comm)</td></tr>
<tr class="memdesc:ab60495d087cbd5c893c5322ba0fa2c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MPI communicator. <br/></td></tr>
<tr class="separator:ab60495d087cbd5c893c5322ba0fa2c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe1b9041308f0855c6be0e05973e660"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafe1b9041308f0855c6be0e05973e660"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResolveShared</b> ()</td></tr>
<tr class="separator:aafe1b9041308f0855c6be0e05973e660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904f35aec841e85367f6db64d8ce3cb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a904f35aec841e85367f6db64d8ce3cb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a904f35aec841e85367f6db64d8ce3cb8">RemoveGhost</a> ()</td></tr>
<tr class="memdesc:a904f35aec841e85367f6db64d8ce3cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all the ghost cells. <br/></td></tr>
<tr class="separator:a904f35aec841e85367f6db64d8ce3cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb95f1e8d6b7987496fc8276c86cf3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5cb95f1e8d6b7987496fc8276c86cf3a">RemoveGhostElements</a> (const HandleType *ghost, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="memdesc:a5cb95f1e8d6b7987496fc8276c86cf3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete some ghost cells provided in array.  <a href="#a5cb95f1e8d6b7987496fc8276c86cf3a">More...</a><br/></td></tr>
<tr class="separator:a5cb95f1e8d6b7987496fc8276c86cf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac883e455fe795e9a7db3cc8c99ac26"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ac883e455fe795e9a7db3cc8c99ac26"></a>
template&lt;typename EType &gt; </td></tr>
<tr class="memitem:a0ac883e455fe795e9a7db3cc8c99ac26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RemoveGhostElements</b> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; EType &gt; &amp;ghost)</td></tr>
<tr class="separator:a0ac883e455fe795e9a7db3cc8c99ac26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c59c400e41943ea87dbb1f0eff1e2bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c59c400e41943ea87dbb1f0eff1e2bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveGhostElements</b> (const <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &amp;ghost)</td></tr>
<tr class="separator:a5c59c400e41943ea87dbb1f0eff1e2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39e30b11f35de81d2a9b8451ef87391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391">AssignGlobalID</a> (ElementType mask)</td></tr>
<tr class="memdesc:ae39e30b11f35de81d2a9b8451ef87391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign unique numbers to elements.  <a href="#ae39e30b11f35de81d2a9b8451ef87391">More...</a><br/></td></tr>
<tr class="separator:ae39e30b11f35de81d2a9b8451ef87391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1067bc3139bb0216f7ce3c1936734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa3e1067bc3139bb0216f7ce3c1936734">ExchangeData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select)</td></tr>
<tr class="memdesc:aa3e1067bc3139bb0216f7ce3c1936734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update data from Shared elements to Ghost elements.  <a href="#aa3e1067bc3139bb0216f7ce3c1936734">More...</a><br/></td></tr>
<tr class="separator:aa3e1067bc3139bb0216f7ce3c1936734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ca81c3d8a01aa6a9ce983769fa03cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd">ExchangeDataBegin</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a35ca81c3d8a01aa6a9ce983769fa03cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous synchronization of data.  <a href="#a35ca81c3d8a01aa6a9ce983769fa03cd">More...</a><br/></td></tr>
<tr class="separator:a35ca81c3d8a01aa6a9ce983769fa03cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443828dada7d0fe8ebcf8040593e1ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1">ExchangeDataEnd</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a443828dada7d0fe8ebcf8040593e1ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete asynchronous synchronization of data.  <a href="#a443828dada7d0fe8ebcf8040593e1ac1">More...</a><br/></td></tr>
<tr class="separator:a443828dada7d0fe8ebcf8040593e1ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064ee931e0f6a75dae38a65d3e8603af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a064ee931e0f6a75dae38a65d3e8603af">ExchangeData</a> (const tag_set &amp;tags, ElementType mask, MarkerType select)</td></tr>
<tr class="memdesc:a064ee931e0f6a75dae38a65d3e8603af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will perform exchange of multiple data tags.  <a href="#a064ee931e0f6a75dae38a65d3e8603af">More...</a><br/></td></tr>
<tr class="separator:a064ee931e0f6a75dae38a65d3e8603af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418d72493b24344d247b811bd980b3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a418d72493b24344d247b811bd980b3a9">ExchangeDataBegin</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a418d72493b24344d247b811bd980b3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize exchange of multiple data tags.  <a href="#a418d72493b24344d247b811bd980b3a9">More...</a><br/></td></tr>
<tr class="separator:a418d72493b24344d247b811bd980b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49bac8c58e4e610eb4c7ec7dd9f4b96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa49bac8c58e4e610eb4c7ec7dd9f4b96">ExchangeDataEnd</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:aa49bac8c58e4e610eb4c7ec7dd9f4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will finalize exchange of multiple data tags.  <a href="#aa49bac8c58e4e610eb4c7ec7dd9f4b96">More...</a><br/></td></tr>
<tr class="separator:aa49bac8c58e4e610eb4c7ec7dd9f4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d488479041917c975b1e662d642c4a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5">ReduceData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, ReduceOperation op)</td></tr>
<tr class="memdesc:a2d488479041917c975b1e662d642c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulation of data from ghost elements to shared elements.  <a href="#a2d488479041917c975b1e662d642c4a5">More...</a><br/></td></tr>
<tr class="separator:a2d488479041917c975b1e662d642c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597bf77b8438dc79bf791912a2b34d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0597bf77b8438dc79bf791912a2b34d2">ReduceDataBegin</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a0597bf77b8438dc79bf791912a2b34d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function intializes data reduction.  <a href="#a0597bf77b8438dc79bf791912a2b34d2">More...</a><br/></td></tr>
<tr class="separator:a0597bf77b8438dc79bf791912a2b34d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8273226d8ab6e54baba5db22107df37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aa8273226d8ab6e54baba5db22107df37">ReduceDataEnd</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, ElementType mask, MarkerType select, ReduceOperation op, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:aa8273226d8ab6e54baba5db22107df37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function completes data reduction.  <a href="#aa8273226d8ab6e54baba5db22107df37">More...</a><br/></td></tr>
<tr class="separator:aa8273226d8ab6e54baba5db22107df37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831a8bab953c4d8aa102e58bac81c25f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a831a8bab953c4d8aa102e58bac81c25f">ReduceData</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, ReduceOperation op)</td></tr>
<tr class="memdesc:a831a8bab953c4d8aa102e58bac81c25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will perform reduction of multiple data tags.  <a href="#a831a8bab953c4d8aa102e58bac81c25f">More...</a><br/></td></tr>
<tr class="separator:a831a8bab953c4d8aa102e58bac81c25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c5b8a155e89d182f18e26dbe4b8670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a71c5b8a155e89d182f18e26dbe4b8670">ReduceDataBegin</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:a71c5b8a155e89d182f18e26dbe4b8670"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize reduction of multiple data tags.  <a href="#a71c5b8a155e89d182f18e26dbe4b8670">More...</a><br/></td></tr>
<tr class="separator:a71c5b8a155e89d182f18e26dbe4b8670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf4380aa2878e72cf399f97598dcebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aabf4380aa2878e72cf399f97598dcebe">ReduceDataEnd</a> (const tag_set &amp;tags, ElementType mask, MarkerType select, ReduceOperation op, <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;storage)</td></tr>
<tr class="memdesc:aabf4380aa2878e72cf399f97598dcebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will finalize exchange of multiple data tags.  <a href="#aabf4380aa2878e72cf399f97598dcebe">More...</a><br/></td></tr>
<tr class="separator:aabf4380aa2878e72cf399f97598dcebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44b9cfcb8964acbd710562df331a51a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a">ExchangeMarked</a> (enum Action action=AGhost)</td></tr>
<tr class="memdesc:ae44b9cfcb8964acbd710562df331a51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function realizes two algorithms: ghosting of elements and migration of elements.  <a href="#ae44b9cfcb8964acbd710562df331a51a">More...</a><br/></td></tr>
<tr class="separator:ae44b9cfcb8964acbd710562df331a51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f72e7c09e74aa9962721646a627650"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ad2f72e7c09e74aa9962721646a627650">ExchangeGhost</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> layers, ElementType bridge)</td></tr>
<tr class="memdesc:ad2f72e7c09e74aa9962721646a627650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form several layers of ghosted cells that are adjacent through bridge elements to current cells.  <a href="#ad2f72e7c09e74aa9962721646a627650">More...</a><br/></td></tr>
<tr class="separator:ad2f72e7c09e74aa9962721646a627650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade20ec7c8563e82bf8057bc47a3314b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7">Redistribute</a> ()</td></tr>
<tr class="memdesc:ade20ec7c8563e82bf8057bc47a3314b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag.  <a href="#ade20ec7c8563e82bf8057bc47a3314b7">More...</a><br/></td></tr>
<tr class="separator:ade20ec7c8563e82bf8057bc47a3314b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9787ba8c75b41b76b89aeeae2e8aefad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9787ba8c75b41b76b89aeeae2e8aefad">Enumerate</a> (ElementType mask, <a class="el" href="classINMOST_1_1Tag.html">Tag</a> num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=false)</td></tr>
<tr class="memdesc:a9787ba8c75b41b76b89aeeae2e8aefad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements begining with start and put numeration to data associated with num_tag for all elements with given type mask.  <a href="#a9787ba8c75b41b76b89aeeae2e8aefad">More...</a><br/></td></tr>
<tr class="separator:a9787ba8c75b41b76b89aeeae2e8aefad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc8c51bea6707ccedc76dba47ea0d48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5dc8c51bea6707ccedc76dba47ea0d48">Enumerate</a> (const HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=true)</td></tr>
<tr class="memdesc:a5dc8c51bea6707ccedc76dba47ea0d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements begining with start and put numeration to data associated with num_tag.  <a href="#a5dc8c51bea6707ccedc76dba47ea0d48">More...</a><br/></td></tr>
<tr class="separator:a5dc8c51bea6707ccedc76dba47ea0d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e7888589b79355fa273ad67c8c9bb5"><td class="memTemplParams" colspan="2">template&lt;typename EType &gt; </td></tr>
<tr class="memitem:a92e7888589b79355fa273ad67c8c9bb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a92e7888589b79355fa273ad67c8c9bb5">Enumerate</a> (const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; EType &gt; &amp;elements, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=true)</td></tr>
<tr class="memdesc:a92e7888589b79355fa273ad67c8c9bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements begining with start and put numeration to data associated with num_tag.  <a href="#a92e7888589b79355fa273ad67c8c9bb5">More...</a><br/></td></tr>
<tr class="separator:a92e7888589b79355fa273ad67c8c9bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0239ff055f17c76ba19ef8a169b14962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a0239ff055f17c76ba19ef8a169b14962">EnumerateSet</a> (const <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &amp;set, const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;num_tag, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> start=0, bool define_sparse=true)</td></tr>
<tr class="memdesc:a0239ff055f17c76ba19ef8a169b14962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all elements in the set.  <a href="#a0239ff055f17c76ba19ef8a169b14962">More...</a><br/></td></tr>
<tr class="separator:a0239ff055f17c76ba19ef8a169b14962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc118e878e2cce11985e7384f18700fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#acc118e878e2cce11985e7384f18700fa">TotalNumberOf</a> (ElementType mask)</td></tr>
<tr class="memdesc:acc118e878e2cce11985e7384f18700fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of all physical elements, it excludes ghosted copies.  <a href="#acc118e878e2cce11985e7384f18700fa">More...</a><br/></td></tr>
<tr class="separator:acc118e878e2cce11985e7384f18700fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90d3db6596d5de6f7ddfd7f72af600f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ab90d3db6596d5de6f7ddfd7f72af600f">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> input)</td></tr>
<tr class="memdesc:ab90d3db6596d5de6f7ddfd7f72af600f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate real value over all processors.  <a href="#ab90d3db6596d5de6f7ddfd7f72af600f">More...</a><br/></td></tr>
<tr class="separator:ab90d3db6596d5de6f7ddfd7f72af600f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541bea07883f3afa0be27748edb479ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a541bea07883f3afa0be27748edb479ff">Integrate</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> input)</td></tr>
<tr class="memdesc:a541bea07883f3afa0be27748edb479ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate integer value over all processors.  <a href="#a541bea07883f3afa0be27748edb479ff">More...</a><br/></td></tr>
<tr class="separator:a541bea07883f3afa0be27748edb479ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1eacb17ae889557d9d9d32d7b61ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#abb1eacb17ae889557d9d9d32d7b61ed0">Integrate</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> entry, ElementType mask)</td></tr>
<tr class="memdesc:abb1eacb17ae889557d9d9d32d7b61ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate data corresponding to tag between all processors.  <a href="#abb1eacb17ae889557d9d9d32d7b61ed0">More...</a><br/></td></tr>
<tr class="separator:abb1eacb17ae889557d9d9d32d7b61ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac1be80eb3f359e6d2834f212131200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8ac1be80eb3f359e6d2834f212131200">ExclusiveSum</a> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> input)</td></tr>
<tr class="memdesc:a8ac1be80eb3f359e6d2834f212131200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sum of integer values for all processors with rank lower then current, excluding current processor.  <a href="#a8ac1be80eb3f359e6d2834f212131200">More...</a><br/></td></tr>
<tr class="separator:a8ac1be80eb3f359e6d2834f212131200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a95b3b375dde1ba544ec0689ce1610f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a95b3b375dde1ba544ec0689ce1610f"></a>
<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> input)</td></tr>
<tr class="separator:a2a95b3b375dde1ba544ec0689ce1610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473a5c93ff000e34b8c07eb1ec9947a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a473a5c93ff000e34b8c07eb1ec9947a1"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AggregateMax</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> input)</td></tr>
<tr class="separator:a473a5c93ff000e34b8c07eb1ec9947a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5691f394480da7e21c5099e313df03e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5691f394480da7e21c5099e313df03e0">RecomputeParallelStorage</a> (ElementType mask)</td></tr>
<tr class="memdesc:a5691f394480da7e21c5099e313df03e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regather ghosted and shared element sets for data exchange.  <a href="#a5691f394480da7e21c5099e313df03e0">More...</a><br/></td></tr>
<tr class="separator:a5691f394480da7e21c5099e313df03e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3acf2a90e25699a64e1f7b4125eaf7"><td class="memItemLeft" align="right" valign="top">ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9c3acf2a90e25699a64e1f7b4125eaf7">SynchronizeElementType</a> (ElementType etype)</td></tr>
<tr class="memdesc:a9c3acf2a90e25699a64e1f7b4125eaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize bitwise mask of element types between processors.  <a href="#a9c3acf2a90e25699a64e1f7b4125eaf7">More...</a><br/></td></tr>
<tr class="separator:a9c3acf2a90e25699a64e1f7b4125eaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a825072f54b260caa0e8da8877647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8c7a825072f54b260caa0e8da8877647">SynchronizeMarker</a> (MarkerType marker, ElementType mask, SyncBitOp op)</td></tr>
<tr class="memdesc:a8c7a825072f54b260caa0e8da8877647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syncronize marker on elements between processors using provided operation.  <a href="#a8c7a825072f54b260caa0e8da8877647">More...</a><br/></td></tr>
<tr class="separator:a8c7a825072f54b260caa0e8da8877647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf9564fe8f57e292e7c2267fbe588d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf9564fe8f57e292e7c2267fbe588d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BeginSequentialCode</b> ()</td></tr>
<tr class="separator:aecf9564fe8f57e292e7c2267fbe588d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f44fe4031bbe9b68ae0764f4b6d43a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4f44fe4031bbe9b68ae0764f4b6d43a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EndSequentialCode</b> ()</td></tr>
<tr class="separator:aa4f44fe4031bbe9b68ae0764f4b6d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedac2611fffd95b7cd20ed9540c743fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedac2611fffd95b7cd20ed9540c743fa"></a>
<a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ElementByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> etypenum, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:aedac2611fffd95b7cd20ed9540c743fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d09a55b27ac2f0f500400648ca38ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9d09a55b27ac2f0f500400648ca38ee"></a>
<a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ElementByLocalID</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:aa9d09a55b27ac2f0f500400648ca38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2304ca5cb8a374ecc6b0b5f0f900e349"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2304ca5cb8a374ecc6b0b5f0f900e349"></a>
<a class="el" href="classINMOST_1_1Element.html">Element</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ElementByHandle</b> (HandleType h)</td></tr>
<tr class="separator:a2304ca5cb8a374ecc6b0b5f0f900e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2584a6bb66add033560e495dbfba53f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2584a6bb66add033560e495dbfba53f"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>NextHandle</b> (HandleType h) const </td></tr>
<tr class="separator:ad2584a6bb66add033560e495dbfba53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6fc997d82528c82499344d358df8d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6fc997d82528c82499344d358df8d0"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>PrevHandle</b> (HandleType h) const </td></tr>
<tr class="separator:acf6fc997d82528c82499344d358df8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ef45248dfb8b5126ca81a7bcd409f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85ef45248dfb8b5126ca81a7bcd409f2"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>NextHandle</b> (HandleType h, ElementType mask) const </td></tr>
<tr class="separator:a85ef45248dfb8b5126ca81a7bcd409f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b510ecffabe4242b3be375b69a4575"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b510ecffabe4242b3be375b69a4575"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>PrevHandle</b> (HandleType h, ElementType mask) const </td></tr>
<tr class="separator:a29b510ecffabe4242b3be375b69a4575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f26f7a8fbf7bf0a104b79f2433334a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f26f7a8fbf7bf0a104b79f2433334a2"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>FirstHandle</b> () const </td></tr>
<tr class="separator:a4f26f7a8fbf7bf0a104b79f2433334a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863be497f888170153331f74fae93e06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a863be497f888170153331f74fae93e06"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>LastHandle</b> () const </td></tr>
<tr class="separator:a863be497f888170153331f74fae93e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9429b9ce591e027f150443891b23e498"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9429b9ce591e027f150443891b23e498"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>FirstHandle</b> (ElementType etype) const </td></tr>
<tr class="separator:a9429b9ce591e027f150443891b23e498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74548f908cf4966d9ce4a3824d0f5b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa74548f908cf4966d9ce4a3824d0f5b6"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>LastHandle</b> (ElementType etype) const </td></tr>
<tr class="separator:aa74548f908cf4966d9ce4a3824d0f5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83562665b8922806e475fa75f79a9b69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83562665b8922806e475fa75f79a9b69"></a>
<a class="el" href="classINMOST_1_1Node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodeByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:a83562665b8922806e475fa75f79a9b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f86a5b9807fa73d7e1ffe493fb1d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a318f86a5b9807fa73d7e1ffe493fb1d0"></a>
<a class="el" href="classINMOST_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:a318f86a5b9807fa73d7e1ffe493fb1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e83bc5a26c47443dd5ae701747ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7e83bc5a26c47443dd5ae701747ccf"></a>
<a class="el" href="classINMOST_1_1Face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FaceByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:aec7e83bc5a26c47443dd5ae701747ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d502f77d8d56014a67e1715f8628c0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d502f77d8d56014a67e1715f8628c0f"></a>
<a class="el" href="classINMOST_1_1Cell.html">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:a0d502f77d8d56014a67e1715f8628c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2af21e0963cd29ae7f809e6e2939719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2af21e0963cd29ae7f809e6e2939719"></a>
<a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetByLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid)</td></tr>
<tr class="separator:af2af21e0963cd29ae7f809e6e2939719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c71407f13fa67febfeb4d0408b9f6f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c71407f13fa67febfeb4d0408b9f6f5"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodeNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:a5c71407f13fa67febfeb4d0408b9f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabec0ed03dc7e55a3f59bc3793bb32f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afabec0ed03dc7e55a3f59bc3793bb32f"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:afabec0ed03dc7e55a3f59bc3793bb32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad878b5d4497a136f8baa22cd74b964d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad878b5d4497a136f8baa22cd74b964d0"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FaceNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:ad878b5d4497a136f8baa22cd74b964d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5ae49f2730b44b3fbdd31977f5662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a5ae49f2730b44b3fbdd31977f5662"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:ae2a5ae49f2730b44b3fbdd31977f5662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c45204c5d0f96410a537e93ad1b0aa7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c45204c5d0f96410a537e93ad1b0aa7"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetNextLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:a8c45204c5d0f96410a537e93ad1b0aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2adb8d94e20e0feba71b971c0529365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2adb8d94e20e0feba71b971c0529365"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodePrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:ad2adb8d94e20e0feba71b971c0529365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a1278d5ee72aa47456b4331fcd1f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4a1278d5ee72aa47456b4331fcd1f0a"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgePrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:ac4a1278d5ee72aa47456b4331fcd1f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f91d6922148a16342ac99f2ed45ff1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99f91d6922148a16342ac99f2ed45ff1"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FacePrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:a99f91d6922148a16342ac99f2ed45ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b35ea5d7f1113518ba8a5a169da55e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1b35ea5d7f1113518ba8a5a169da55e"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellPrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:ab1b35ea5d7f1113518ba8a5a169da55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38105dd04581e661e800db9cd9da3b18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38105dd04581e661e800db9cd9da3b18"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetPrevLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:a38105dd04581e661e800db9cd9da3b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80eb9de7883ddfa176e9acefdc019c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa80eb9de7883ddfa176e9acefdc019c7"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NodeLastLocalID</b> () const </td></tr>
<tr class="separator:aa80eb9de7883ddfa176e9acefdc019c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa49ab28fa20915aaaea68a6a3ec5ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa49ab28fa20915aaaea68a6a3ec5ac"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EdgeLastLocalID</b> () const </td></tr>
<tr class="separator:abfa49ab28fa20915aaaea68a6a3ec5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf8c4d6d2122d3221dd99e20a430ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bdf8c4d6d2122d3221dd99e20a430ea"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FaceLastLocalID</b> () const </td></tr>
<tr class="separator:a5bdf8c4d6d2122d3221dd99e20a430ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46e642c492612e156a9e85a67b2305d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac46e642c492612e156a9e85a67b2305d"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CellLastLocalID</b> () const </td></tr>
<tr class="separator:ac46e642c492612e156a9e85a67b2305d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf65bc7bb30f0c80ff196914964f7c1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf65bc7bb30f0c80ff196914964f7c1a"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EsetLastLocalID</b> () const </td></tr>
<tr class="separator:aaf65bc7bb30f0c80ff196914964f7c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692fbbc2f3ccaf3b8951c20ec0b14a19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a692fbbc2f3ccaf3b8951c20ec0b14a19"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NextLocalID</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:a692fbbc2f3ccaf3b8951c20ec0b14a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751a12b5299610c2ecbfd935fc3efcfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a751a12b5299610c2ecbfd935fc3efcfe"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PrevLocalID</b> (ElementType etype, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> lid) const </td></tr>
<tr class="separator:a751a12b5299610c2ecbfd935fc3efcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9911e8e9d0e92983cd075b16a5afe2bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9911e8e9d0e92983cd075b16a5afe2bf"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FirstLocalID</b> (ElementType etype) const </td></tr>
<tr class="separator:a9911e8e9d0e92983cd075b16a5afe2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a2ff7416bb492e1cdd095ca9c91e85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06a2ff7416bb492e1cdd095ca9c91e85"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LastLocalID</b> (<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> n) const </td></tr>
<tr class="separator:a06a2ff7416bb492e1cdd095ca9c91e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c34383e2eefea680d1217af76a381f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34c34383e2eefea680d1217af76a381f"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LastLocalID</b> (ElementType etype) const </td></tr>
<tr class="separator:a34c34383e2eefea680d1217af76a381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeaa462c78ce8a82e0e3e87c55e4455"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeeaa462c78ce8a82e0e3e87c55e4455"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfSets</b> () const </td></tr>
<tr class="separator:abeeaa462c78ce8a82e0e3e87c55e4455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245f0558fa7181cf6789db69c4005b33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a245f0558fa7181cf6789db69c4005b33"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfCells</b> () const </td></tr>
<tr class="separator:a245f0558fa7181cf6789db69c4005b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67db1a1d141e8d7cb93ca1284777bb08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67db1a1d141e8d7cb93ca1284777bb08"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfFaces</b> () const </td></tr>
<tr class="separator:a67db1a1d141e8d7cb93ca1284777bb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404c19f0ddf24cd968de766cf130b371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a404c19f0ddf24cd968de766cf130b371"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfEdges</b> () const </td></tr>
<tr class="separator:a404c19f0ddf24cd968de766cf130b371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4562c5fd5341705ed706b3c4cfda80fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4562c5fd5341705ed706b3c4cfda80fe"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfNodes</b> () const </td></tr>
<tr class="separator:a4562c5fd5341705ed706b3c4cfda80fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aee6d7f5b7432dc34bc7319a9e1e8f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aee6d7f5b7432dc34bc7319a9e1e8f4"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfElements</b> () const </td></tr>
<tr class="separator:a7aee6d7f5b7432dc34bc7319a9e1e8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8e4c3631d8448e738f26cfc99e6871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8e4c3631d8448e738f26cfc99e6871"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOfAll</b> () const </td></tr>
<tr class="separator:a8f8e4c3631d8448e738f26cfc99e6871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c44999830564f5abfbc6920dbe4a1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c44999830564f5abfbc6920dbe4a1b"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NumberOf</b> (ElementType t) const </td></tr>
<tr class="separator:a51c44999830564f5abfbc6920dbe4a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee057ff8894f5920556eea758f45a05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaee057ff8894f5920556eea758f45a05"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorStorage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aaee057ff8894f5920556eea758f45a05">Begin</a> (ElementType Types)</td></tr>
<tr class="memdesc:aaee057ff8894f5920556eea758f45a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">These iterators skip invalid elements but don't skip modified elements. <br/></td></tr>
<tr class="separator:aaee057ff8894f5920556eea758f45a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4075ba5683113b9da966ee8254c9c98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4075ba5683113b9da966ee8254c9c98"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorStorage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>End</b> ()</td></tr>
<tr class="separator:ab4075ba5683113b9da966ee8254c9c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5885febfabd0c64ca2147f2508c676ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5885febfabd0c64ca2147f2508c676ae"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorElement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginElement</b> (ElementType Types)</td></tr>
<tr class="separator:a5885febfabd0c64ca2147f2508c676ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceafaeeef67b517d363d19249c9aae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ceafaeeef67b517d363d19249c9aae7"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorElement</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndElement</b> ()</td></tr>
<tr class="separator:a7ceafaeeef67b517d363d19249c9aae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e1a950b5a5f7ad600d55226023b7c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5e1a950b5a5f7ad600d55226023b7c9"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginSet</b> ()</td></tr>
<tr class="separator:aa5e1a950b5a5f7ad600d55226023b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f6929baaaf379644dddef6c42fef76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00f6929baaaf379644dddef6c42fef76"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorSet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndSet</b> ()</td></tr>
<tr class="separator:a00f6929baaaf379644dddef6c42fef76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7a5c1d76ed3816d0167adac44d0a24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c7a5c1d76ed3816d0167adac44d0a24"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorCell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginCell</b> ()</td></tr>
<tr class="separator:a0c7a5c1d76ed3816d0167adac44d0a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00d0cd949a89a3bf9ff0802d5292e82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad00d0cd949a89a3bf9ff0802d5292e82"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorCell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndCell</b> ()</td></tr>
<tr class="separator:ad00d0cd949a89a3bf9ff0802d5292e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b92935c9e005193abf21f24f701fa07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b92935c9e005193abf21f24f701fa07"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorFace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginFace</b> ()</td></tr>
<tr class="separator:a8b92935c9e005193abf21f24f701fa07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5324c63941c77b2fc4654e5c2774b845"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5324c63941c77b2fc4654e5c2774b845"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorFace</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndFace</b> ()</td></tr>
<tr class="separator:a5324c63941c77b2fc4654e5c2774b845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5215f1e7a43a336c68819a92780b89d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5215f1e7a43a336c68819a92780b89d5"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginEdge</b> ()</td></tr>
<tr class="separator:a5215f1e7a43a336c68819a92780b89d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f40383f4780d877be0291b5d1c4c85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2f40383f4780d877be0291b5d1c4c85"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndEdge</b> ()</td></tr>
<tr class="separator:ac2f40383f4780d877be0291b5d1c4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab832696d5dfd3340153dedb5dc86974d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab832696d5dfd3340153dedb5dc86974d"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BeginNode</b> ()</td></tr>
<tr class="separator:ab832696d5dfd3340153dedb5dc86974d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e61945ab061054cf896db3831d7ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a424e61945ab061054cf896db3831d7ec"></a>
<a class="el" href="classINMOST_1_1Mesh_1_1base__iterator.html">iteratorNode</a>&#160;</td><td class="memItemRight" valign="bottom"><b>EndNode</b> ()</td></tr>
<tr class="separator:a424e61945ab061054cf896db3831d7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c75e9dee2c400225a6095e45489ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a07c75e9dee2c400225a6095e45489ac1">SetFileOption</a> (std::string, std::string)</td></tr>
<tr class="memdesc:a07c75e9dee2c400225a6095e45489ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set file option.  <a href="#a07c75e9dee2c400225a6095e45489ac1">More...</a><br/></td></tr>
<tr class="separator:a07c75e9dee2c400225a6095e45489ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5d5a48564cae0b29d152cc40673632"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1b5d5a48564cae0b29d152cc40673632">GetFileOption</a> (std::string key)</td></tr>
<tr class="memdesc:a1b5d5a48564cae0b29d152cc40673632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current option corresponding to key.  <a href="#a1b5d5a48564cae0b29d152cc40673632">More...</a><br/></td></tr>
<tr class="separator:a1b5d5a48564cae0b29d152cc40673632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfd481d638b2d2d72193b4b8fa159a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5dfd481d638b2d2d72193b4b8fa159a4">Load</a> (std::string File)</td></tr>
<tr class="memdesc:a5dfd481d638b2d2d72193b4b8fa159a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptable file formats for reading.  <a href="#a5dfd481d638b2d2d72193b4b8fa159a4">More...</a><br/></td></tr>
<tr class="separator:a5dfd481d638b2d2d72193b4b8fa159a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12ba58210b79c61e64a74c389cd11f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#ac12ba58210b79c61e64a74c389cd11f6">Save</a> (std::string File)</td></tr>
<tr class="memdesc:ac12ba58210b79c61e64a74c389cd11f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acceptable file formats for writing.  <a href="#ac12ba58210b79c61e64a74c389cd11f6">More...</a><br/></td></tr>
<tr class="separator:ac12ba58210b79c61e64a74c389cd11f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed94fed9a6ebc229a814c562c2a683"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61ed94fed9a6ebc229a814c562c2a683"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isParallelFileFormat</b> (std::string File)</td></tr>
<tr class="separator:a61ed94fed9a6ebc229a814c562c2a683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ff8ea3298e7ff39ccffdaaa1ebef58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ff8ea3298e7ff39ccffdaaa1ebef58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrepareGeometricData</b> (GeomParam table)</td></tr>
<tr class="separator:af4ff8ea3298e7ff39ccffdaaa1ebef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aaadf5c297568d18cd9a23df11535a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04aaadf5c297568d18cd9a23df11535a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemoveGeometricData</b> (GeomParam table)</td></tr>
<tr class="separator:a04aaadf5c297568d18cd9a23df11535a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10797f897575540e8f44e4ca9482dbc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10797f897575540e8f44e4ca9482dbc0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HaveGeometricData</b> (GeometricData type, ElementType mask) const </td></tr>
<tr class="separator:a10797f897575540e8f44e4ca9482dbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baaeba7978ddf3449399428e8d4e11a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3baaeba7978ddf3449399428e8d4e11a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetGeometricData</b> (HandleType e, GeometricData type, <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *ret)</td></tr>
<tr class="separator:a3baaeba7978ddf3449399428e8d4e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b06fc7b7cfe675c5170e839a3b4734"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b06fc7b7cfe675c5170e839a3b4734"></a>
const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetGeometricTag</b> (GeometricData type) const </td></tr>
<tr class="separator:a82b06fc7b7cfe675c5170e839a3b4734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb643b1cad35149e667357beb4c24fa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb643b1cad35149e667357beb4c24fa9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>TestClosure</b> (const HandleType *elements, <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> num) const </td></tr>
<tr class="separator:aeb643b1cad35149e667357beb4c24fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe976b702bcc86662c1551df5ed26a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe976b702bcc86662c1551df5ed26a8"></a>
<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GatherBoundaryFaces</b> ()</td></tr>
<tr class="separator:a8fe976b702bcc86662c1551df5ed26a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a1985acd5676d83a8f5d9aa6b0e927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89a1985acd5676d83a8f5d9aa6b0e927"></a>
<a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; <a class="el" href="classINMOST_1_1Face.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GatherInteriorFaces</b> ()</td></tr>
<tr class="separator:a89a1985acd5676d83a8f5d9aa6b0e927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fac7af473402381cb2b967f4ae057c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28fac7af473402381cb2b967f4ae057c"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CountBoundaryFaces</b> ()</td></tr>
<tr class="separator:a28fac7af473402381cb2b967f4ae057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89ada8254d449794ab4f55815963ecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89ada8254d449794ab4f55815963ecb"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CountInteriorFaces</b> ()</td></tr>
<tr class="separator:af89ada8254d449794ab4f55815963ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263ae4c38b01550f28ee6f502d75246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1263ae4c38b01550f28ee6f502d75246"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RecomputeGeometricData</b> (HandleType e)</td></tr>
<tr class="separator:a1263ae4c38b01550f28ee6f502d75246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7891840e8ed563be5b88da0f8b7f95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e7891840e8ed563be5b88da0f8b7f95"></a>
Element::GeometricType&#160;</td><td class="memItemRight" valign="bottom"><b>ComputeGeometricType</b> (ElementType element_type, const HandleType *lower_adjacent, INMOST_DATA_ENUM_TYPE lower_adjacent_size) const </td></tr>
<tr class="separator:a3e7891840e8ed563be5b88da0f8b7f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870a18031c98f36972e6df4c21859a28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a870a18031c98f36972e6df4c21859a28">isMeshModified</a> () const </td></tr>
<tr class="memdesc:a870a18031c98f36972e6df4c21859a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check weather code runs between Mesh::BeginModification, Mesh::EndModification scope.  <a href="#a870a18031c98f36972e6df4c21859a28">More...</a><br/></td></tr>
<tr class="separator:a870a18031c98f36972e6df4c21859a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad113bb7fdc195cda837274fd9cdda4a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad113bb7fdc195cda837274fd9cdda4a2"></a>
MarkerType&#160;</td><td class="memItemRight" valign="bottom"><b>HideMarker</b> () const </td></tr>
<tr class="separator:ad113bb7fdc195cda837274fd9cdda4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0456acc039a3199e0d7e38d6d1a72400"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0456acc039a3199e0d7e38d6d1a72400"></a>
MarkerType&#160;</td><td class="memItemRight" valign="bottom"><b>NewMarker</b> () const </td></tr>
<tr class="separator:a0456acc039a3199e0d7e38d6d1a72400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0175d8aad4ca37cdf5ad67627204ded"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0175d8aad4ca37cdf5ad67627204ded"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SwapModification</b> ()</td></tr>
<tr class="separator:ac0175d8aad4ca37cdf5ad67627204ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0c0ff2608666651ef66adc1c143352"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef0c0ff2608666651ef66adc1c143352"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BeginModification</b> ()</td></tr>
<tr class="separator:aef0c0ff2608666651ef66adc1c143352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f53070855f3503b2f4cefc16cedd6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1f53070855f3503b2f4cefc16cedd6a0">ApplyModification</a> ()</td></tr>
<tr class="memdesc:a1f53070855f3503b2f4cefc16cedd6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">After this function any link to deleted element will be replaced by InvalidHandle().  <a href="#a1f53070855f3503b2f4cefc16cedd6a0">More...</a><br/></td></tr>
<tr class="separator:a1f53070855f3503b2f4cefc16cedd6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60274817b98e76ec5a411f0c3df2a76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a60274817b98e76ec5a411f0c3df2a76b">ResolveModification</a> ()</td></tr>
<tr class="memdesc:a60274817b98e76ec5a411f0c3df2a76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is not yet implemented.  <a href="#a60274817b98e76ec5a411f0c3df2a76b">More...</a><br/></td></tr>
<tr class="separator:a60274817b98e76ec5a411f0c3df2a76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dacf6bdaf0654c5a2ad5d2d6e57966"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1dacf6bdaf0654c5a2ad5d2d6e57966"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EndModification</b> ()</td></tr>
<tr class="separator:ac1dacf6bdaf0654c5a2ad5d2d6e57966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c61eda9492c7167ec7c02ac1ba50ebc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c61eda9492c7167ec7c02ac1ba50ebc"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNext</b> (const HandleType *arr, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> k, MarkerType marker) const </td></tr>
<tr class="separator:a9c61eda9492c7167ec7c02ac1ba50ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819d63c1a65ceaa138bdb8131e2fc97d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a819d63c1a65ceaa138bdb8131e2fc97d"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Count</b> (const HandleType *arr, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> size, MarkerType marker) const </td></tr>
<tr class="separator:a819d63c1a65ceaa138bdb8131e2fc97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55549e9d46cd92e2f3122e1516f3c9fd"><td class="memItemLeft" align="right" valign="top">TopologyCheck&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a55549e9d46cd92e2f3122e1516f3c9fd">BeginTopologyCheck</a> (ElementType etype, const HandleType *adj, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="memdesc:a55549e9d46cd92e2f3122e1516f3c9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allows you to perform some topologycal checks before you create an element.  <a href="#a55549e9d46cd92e2f3122e1516f3c9fd">More...</a><br/></td></tr>
<tr class="separator:a55549e9d46cd92e2f3122e1516f3c9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6c26bcbe6e7a0cba093c0b8312ba04"><td class="memItemLeft" align="right" valign="top">TopologyCheck&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1c6c26bcbe6e7a0cba093c0b8312ba04">EndTopologyCheck</a> (HandleType e)</td></tr>
<tr class="memdesc:a1c6c26bcbe6e7a0cba093c0b8312ba04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs some topologycal checks after creation of element.  <a href="#a1c6c26bcbe6e7a0cba093c0b8312ba04">More...</a><br/></td></tr>
<tr class="separator:a1c6c26bcbe6e7a0cba093c0b8312ba04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ee27b1b485c40e272f8018aa5ca0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a72ee27b1b485c40e272f8018aa5ca0a1">TopologyErrorTag</a> () const </td></tr>
<tr class="memdesc:a72ee27b1b485c40e272f8018aa5ca0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will return tag by which you can retrieve error mark to any element on which topogy check failed.  <a href="#a72ee27b1b485c40e272f8018aa5ca0a1">More...</a><br/></td></tr>
<tr class="separator:a72ee27b1b485c40e272f8018aa5ca0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad6ccd8132d0aed639ef18772def9ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afad6ccd8132d0aed639ef18772def9ab"></a>
TopologyCheck&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#afad6ccd8132d0aed639ef18772def9ab">GetTopologyCheck</a> (TopologyCheck mask=ENUMUNDEF) const </td></tr>
<tr class="memdesc:afad6ccd8132d0aed639ef18772def9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve currently set topology checks. <br/></td></tr>
<tr class="separator:afad6ccd8132d0aed639ef18772def9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f578239d7b369ad4b1edb69eea24d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9f578239d7b369ad4b1edb69eea24d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#af9f578239d7b369ad4b1edb69eea24d2">SetTopologyCheck</a> (TopologyCheck mask)</td></tr>
<tr class="memdesc:af9f578239d7b369ad4b1edb69eea24d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set topology checks. <br/></td></tr>
<tr class="separator:af9f578239d7b369ad4b1edb69eea24d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374a56ae3bdae9e54030c72538836c09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a374a56ae3bdae9e54030c72538836c09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a374a56ae3bdae9e54030c72538836c09">RemTopologyCheck</a> (TopologyCheck mask)</td></tr>
<tr class="memdesc:a374a56ae3bdae9e54030c72538836c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove topology checks. <br/></td></tr>
<tr class="separator:a374a56ae3bdae9e54030c72538836c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6bf21484fbe477cde2234ddef555e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ac6bf21484fbe477cde2234ddef555e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a5ac6bf21484fbe477cde2234ddef555e">SetTopologyError</a> (TopologyCheck mask)</td></tr>
<tr class="memdesc:a5ac6bf21484fbe477cde2234ddef555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will turn mesh into the state indicating that some topology error occured. <br/></td></tr>
<tr class="separator:a5ac6bf21484fbe477cde2234ddef555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedab01e9e2b9f6294f20a148719998ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedab01e9e2b9f6294f20a148719998ea"></a>
TopologyCheck&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aedab01e9e2b9f6294f20a148719998ea">GetTopologyError</a> (TopologyCheck mask=ENUMUNDEF) const </td></tr>
<tr class="memdesc:aedab01e9e2b9f6294f20a148719998ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve topology error state, this indicates that some error have occured. <br/></td></tr>
<tr class="separator:aedab01e9e2b9f6294f20a148719998ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4d3c7dd08bd37844494d08adf8ac2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d4d3c7dd08bd37844494d08adf8ac2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a1d4d3c7dd08bd37844494d08adf8ac2f">ClearTopologyError</a> (TopologyCheck mask=ENUMUNDEF)</td></tr>
<tr class="memdesc:a1d4d3c7dd08bd37844494d08adf8ac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revert mesh to clean topology error state. <br/></td></tr>
<tr class="separator:a1d4d3c7dd08bd37844494d08adf8ac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49994e93f25513716f352933f5c0599"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae49994e93f25513716f352933f5c0599"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SortHandles</b> (HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="separator:ae49994e93f25513716f352933f5c0599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8cfa72de874bd9a17fb0067ac8d515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a9f8cfa72de874bd9a17fb0067ac8d515">SortByGlobalID</a> (HandleType *h, <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> num)</td></tr>
<tr class="separator:a9f8cfa72de874bd9a17fb0067ac8d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:a61d1c149756989d61868d41e374d7c76 inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61d1c149756989d61868d41e374d7c76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HaveTag</b> (std::string name) const </td></tr>
<tr class="separator:a61d1c149756989d61868d41e374d7c76 inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadbec8cfb140793eb5a594649ba0247 inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeadbec8cfb140793eb5a594649ba0247"></a>
<a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetTag</b> (std::string name) const </td></tr>
<tr class="separator:aeadbec8cfb140793eb5a594649ba0247 inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb782655ad079208d1b2b6e614d0499 inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bb782655ad079208d1b2b6e614d0499"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ListTagNames</b> (std::vector&lt; std::string &gt; &amp;list) const </td></tr>
<tr class="separator:a5bb782655ad079208d1b2b6e614d0499 inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b7509d389191f59772bf5defc931b inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85b7509d389191f59772bf5defc931b"></a>
<a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CreateTag</b> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *m, std::string name, DataType dtype, ElementType etype, ElementType sparse, INMOST_DATA_ENUM_TYPE size=ENUMUNDEF)</td></tr>
<tr class="separator:ac85b7509d389191f59772bf5defc931b inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c0dbd9ead879cc09e3c497b95b954 inherit pub_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a320c0dbd9ead879cc09e3c497b95b954"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ElementDefined</b> (<a class="el" href="classINMOST_1_1Tag.html">Tag</a> const &amp;tag, ElementType etype) const </td></tr>
<tr class="separator:a320c0dbd9ead879cc09e3c497b95b954 inherit pub_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classINMOST_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classINMOST_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classINMOST_1_1Storage.html">INMOST::Storage</a></td></tr>
<tr class="memitem:adf1bf5a77779751b057db0d2a1d5defc inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf1bf5a77779751b057db0d2a1d5defc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Storage</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="separator:adf1bf5a77779751b057db0d2a1d5defc inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54484f34481cbd2583588f7ca502521 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab54484f34481cbd2583588f7ca502521"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Storage</b> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *mesh, HandleType handle)</td></tr>
<tr class="separator:ab54484f34481cbd2583588f7ca502521 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd7d01b2f05bf061ba8439fd1d25599 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fd7d01b2f05bf061ba8439fd1d25599"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a9fd7d01b2f05bf061ba8439fd1d25599">Storage</a> (<a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *mesh, HandleType *handle)</td></tr>
<tr class="memdesc:a9fd7d01b2f05bf061ba8439fd1d25599 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor allows for remote handle modification. <br/></td></tr>
<tr class="separator:a9fd7d01b2f05bf061ba8439fd1d25599 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156c939c83d6854e1efaa29c1c38dddb inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a156c939c83d6854e1efaa29c1c38dddb"></a>
<a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a156c939c83d6854e1efaa29c1c38dddb">operator=</a> (<a class="el" href="classINMOST_1_1Storage.html">Storage</a> const &amp;other)</td></tr>
<tr class="memdesc:a156c939c83d6854e1efaa29c1c38dddb inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a link to handle provided (automatically by <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a> and <a class="el" href="classINMOST_1_1Storage_1_1reference__array.html" title="Storage type for representing arrays of Element references. ">reference_array</a>), then remote handle value will be modified. <br/></td></tr>
<tr class="separator:a156c939c83d6854e1efaa29c1c38dddb inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3431bf6dbdbdfb4beaf2cac0f319a4 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c3431bf6dbdbdfb4beaf2cac0f319a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="separator:a2c3431bf6dbdbdfb4beaf2cac0f319a4 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdd5cda6a98308a3ac442b119a7c406 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fdd5cda6a98308a3ac442b119a7c406"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;other)</td></tr>
<tr class="separator:a4fdd5cda6a98308a3ac442b119a7c406 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53cbc67f9303555dc4fc657638b75e2 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa53cbc67f9303555dc4fc657638b75e2"></a>
<a class="el" href="classINMOST_1_1Storage.html">Storage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> ()</td></tr>
<tr class="separator:aa53cbc67f9303555dc4fc657638b75e2 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b258b0537667008d570b1ebfbdff1cc inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b258b0537667008d570b1ebfbdff1cc"></a>
const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator-&gt;</b> () const </td></tr>
<tr class="separator:a7b258b0537667008d570b1ebfbdff1cc inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74072ef234bfe67ed7f46f3adb3abf5a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74072ef234bfe67ed7f46f3adb3abf5a"></a>
<a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> ()</td></tr>
<tr class="separator:a74072ef234bfe67ed7f46f3adb3abf5a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f75e7b6a5229dfbdbc946cba466ec4 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30f75e7b6a5229dfbdbc946cba466ec4"></a>
const <a class="el" href="classINMOST_1_1Storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>self</b> () const </td></tr>
<tr class="separator:a30f75e7b6a5229dfbdbc946cba466ec4 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace95cd4dc7a18215d2b67fac8580dd52 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace95cd4dc7a18215d2b67fac8580dd52"></a>
<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ace95cd4dc7a18215d2b67fac8580dd52">Real</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:ace95cd4dc7a18215d2b67fac8580dd52 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve real value associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:ace95cd4dc7a18215d2b67fac8580dd52 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802727f198dcfd7436fbc3a5080c6d88 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a802727f198dcfd7436fbc3a5080c6d88"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a802727f198dcfd7436fbc3a5080c6d88">Integer</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a802727f198dcfd7436fbc3a5080c6d88 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve integer value associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:a802727f198dcfd7436fbc3a5080c6d88 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df0b301d16530712d24d4a3c7ec4d3e inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df0b301d16530712d24d4a3c7ec4d3e"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a6df0b301d16530712d24d4a3c7ec4d3e">Bulk</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a6df0b301d16530712d24d4a3c7ec4d3e inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve one byte of abstract data associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:a6df0b301d16530712d24d4a3c7ec4d3e inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2433d2e9fdad1de2af584f4fbf318617 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2433d2e9fdad1de2af584f4fbf318617"></a>
<a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a2433d2e9fdad1de2af584f4fbf318617">Reference</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a2433d2e9fdad1de2af584f4fbf318617 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve <a class="el" href="classINMOST_1_1Element.html">Element</a> reference associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:a2433d2e9fdad1de2af584f4fbf318617 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45683e543b10f3ca94595fdbb43f2dd7 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45683e543b10f3ca94595fdbb43f2dd7"></a>
<a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a45683e543b10f3ca94595fdbb43f2dd7">RealArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a45683e543b10f3ca94595fdbb43f2dd7 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of real values associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:a45683e543b10f3ca94595fdbb43f2dd7 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee19d33f10109b8076ed722d03ef3d3b inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee19d33f10109b8076ed722d03ef3d3b"></a>
<a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#aee19d33f10109b8076ed722d03ef3d3b">IntegerArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:aee19d33f10109b8076ed722d03ef3d3b inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of integer values associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:aee19d33f10109b8076ed722d03ef3d3b inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06fda6f458c36197b5a05d9bee5b220 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab06fda6f458c36197b5a05d9bee5b220"></a>
<a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ab06fda6f458c36197b5a05d9bee5b220">BulkArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:ab06fda6f458c36197b5a05d9bee5b220 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve abstract data associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a> as a series of bytes. <br/></td></tr>
<tr class="separator:ab06fda6f458c36197b5a05d9bee5b220 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4635fde0dc22cb26d52fce6cdff9247 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4635fde0dc22cb26d52fce6cdff9247"></a>
<a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ad4635fde0dc22cb26d52fce6cdff9247">ReferenceArray</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:ad4635fde0dc22cb26d52fce6cdff9247 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve array of <a class="el" href="classINMOST_1_1Element.html">Element</a> references associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:ad4635fde0dc22cb26d52fce6cdff9247 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86362a22500a13f4d5d982237df2455d inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86362a22500a13f4d5d982237df2455d"></a>
<a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RealArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a86362a22500a13f4d5d982237df2455d inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa2b3a048dbc2202382064f7eea2e58 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaa2b3a048dbc2202382064f7eea2e58"></a>
<a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:aaaa2b3a048dbc2202382064f7eea2e58 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0811a9fe56b68a571808a9e198f15c inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab0811a9fe56b68a571808a9e198f15c"></a>
<a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BulkArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:aab0811a9fe56b68a571808a9e198f15c inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc35892f554c1bb4ca0bad03f64cef9 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cc35892f554c1bb4ca0bad03f64cef9"></a>
<a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceArrayDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a4cc35892f554c1bb4ca0bad03f64cef9 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61c1fc5e91ff5bc3e009e01870d7ad9 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac61c1fc5e91ff5bc3e009e01870d7ad9"></a>
<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RealDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:ac61c1fc5e91ff5bc3e009e01870d7ad9 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e72d878654feabe107a74b790b715e inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e72d878654feabe107a74b790b715e"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:ab9e72d878654feabe107a74b790b715e inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d96258748000b4ffd08e0c283757655 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d96258748000b4ffd08e0c283757655"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>BulkDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a0d96258748000b4ffd08e0c283757655 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0a45cd8b835451b963d2d6789cc76b inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a0a45cd8b835451b963d2d6789cc76b"></a>
<a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceDF</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a4a0a45cd8b835451b963d2d6789cc76b inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf94d4d967a234ee124615f54f9ae0a0 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf94d4d967a234ee124615f54f9ae0a0"></a>
<a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RealArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:aaf94d4d967a234ee124615f54f9ae0a0 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aca9f6585bdfdbbaa5e053a4a72bb70 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9aca9f6585bdfdbbaa5e053a4a72bb70"></a>
<a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a9aca9f6585bdfdbbaa5e053a4a72bb70 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78451cbe91031bb9ebdaeecba66658a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa78451cbe91031bb9ebdaeecba66658a"></a>
<a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BulkArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:aa78451cbe91031bb9ebdaeecba66658a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4484db2915bc633bbc5310bc00ee8a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe4484db2915bc633bbc5310bc00ee8a"></a>
<a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceArrayDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:afe4484db2915bc633bbc5310bc00ee8a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e5f595ccb081dfa09537a9f9abc570 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19e5f595ccb081dfa09537a9f9abc570"></a>
<a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RealDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a19e5f595ccb081dfa09537a9f9abc570 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2f6952652596994f88cce7cc97604a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a2f6952652596994f88cce7cc97604a"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>IntegerDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a4a2f6952652596994f88cce7cc97604a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad660844d3dad1ab9079065ef0e597b20 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad660844d3dad1ab9079065ef0e597b20"></a>
<a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>BulkDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:ad660844d3dad1ab9079065ef0e597b20 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7432a2e64b3ac57860deb252087b2f66 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7432a2e64b3ac57860deb252087b2f66"></a>
<a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceDV</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a7432a2e64b3ac57860deb252087b2f66 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c416b8e55014921426055508deca124 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">INMOST_DATA_ENUM_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a0c416b8e55014921426055508deca124">GetDataSize</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a0c416b8e55014921426055508deca124 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data length associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>.  <a href="#a0c416b8e55014921426055508deca124">More...</a><br/></td></tr>
<tr class="separator:a0c416b8e55014921426055508deca124 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af834468fb65cd43e272502985c050820 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#af834468fb65cd43e272502985c050820">SetDataSize</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, INMOST_DATA_ENUM_TYPE new_size) const </td></tr>
<tr class="memdesc:af834468fb65cd43e272502985c050820 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the length of data associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>.  <a href="#af834468fb65cd43e272502985c050820">More...</a><br/></td></tr>
<tr class="separator:af834468fb65cd43e272502985c050820 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dc4f3507b7f327fb29ae48311a4eea inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ae5dc4f3507b7f327fb29ae48311a4eea">GetData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, INMOST_DATA_ENUM_TYPE shift, INMOST_DATA_ENUM_TYPE size, void *data) const </td></tr>
<tr class="memdesc:ae5dc4f3507b7f327fb29ae48311a4eea inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract part of the data associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>.  <a href="#ae5dc4f3507b7f327fb29ae48311a4eea">More...</a><br/></td></tr>
<tr class="separator:ae5dc4f3507b7f327fb29ae48311a4eea inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8cae6a4325c80da00fe9c9befaf300 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb8cae6a4325c80da00fe9c9befaf300"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetData</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag, INMOST_DATA_ENUM_TYPE shift, INMOST_DATA_ENUM_TYPE size, const void *data) const </td></tr>
<tr class="separator:aeb8cae6a4325c80da00fe9c9befaf300 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e09e97adc4e172ebef2738b3ee1e2e6 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e09e97adc4e172ebef2738b3ee1e2e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DelData</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="separator:a1e09e97adc4e172ebef2738b3ee1e2e6 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bea3510b025f9083dbccd1fbdb94607 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bea3510b025f9083dbccd1fbdb94607"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a9bea3510b025f9083dbccd1fbdb94607">DelSparseData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:a9bea3510b025f9083dbccd1fbdb94607 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates space allocated for sparse data, frees variable array if necessary. <br/></td></tr>
<tr class="separator:a9bea3510b025f9083dbccd1fbdb94607 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af528c745af38f31bf6b8b77c1eafdb8a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af528c745af38f31bf6b8b77c1eafdb8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#af528c745af38f31bf6b8b77c1eafdb8a">DelDenseData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:af528c745af38f31bf6b8b77c1eafdb8a inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees variable array or fills field with zeroes. <br/></td></tr>
<tr class="separator:af528c745af38f31bf6b8b77c1eafdb8a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94105e63f94f9799ff9a58280d0bf63 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab94105e63f94f9799ff9a58280d0bf63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#ab94105e63f94f9799ff9a58280d0bf63">HaveData</a> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;tag) const </td></tr>
<tr class="memdesc:ab94105e63f94f9799ff9a58280d0bf63 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any data is associated with <a class="el" href="classINMOST_1_1Tag.html">Tag</a>. <br/></td></tr>
<tr class="separator:ab94105e63f94f9799ff9a58280d0bf63 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6928532b6665a12831d13293c4c7b31 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6928532b6665a12831d13293c4c7b31"></a>
__INLINE ElementType&#160;</td><td class="memItemRight" valign="bottom"><b>GetElementType</b> () const </td></tr>
<tr class="separator:ae6928532b6665a12831d13293c4c7b31 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29350683bf09e402e0343f758f3e9d1 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae29350683bf09e402e0343f758f3e9d1"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetElementNum</b> () const </td></tr>
<tr class="separator:ae29350683bf09e402e0343f758f3e9d1 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9786e860933f2ab0970010ab4bcfc567 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9786e860933f2ab0970010ab4bcfc567"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMarker</b> (MarkerType n) const </td></tr>
<tr class="separator:a9786e860933f2ab0970010ab4bcfc567 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfbb42c2b3e6dbe03894c48e0ab4639 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cfbb42c2b3e6dbe03894c48e0ab4639"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetMarker</b> (MarkerType n) const </td></tr>
<tr class="separator:a8cfbb42c2b3e6dbe03894c48e0ab4639 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b31f315682afcdb92e70a29d840650a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b31f315682afcdb92e70a29d840650a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RemMarker</b> (MarkerType n) const </td></tr>
<tr class="separator:a4b31f315682afcdb92e70a29d840650a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ea32f722414ba7422366078d3e71da inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32ea32f722414ba7422366078d3e71da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearMarkerSpace</b> () const </td></tr>
<tr class="separator:a32ea32f722414ba7422366078d3e71da inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae571daade7e16b5cb436a677ef7e2e0a inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae571daade7e16b5cb436a677ef7e2e0a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetMarkerSpace</b> (<a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> copy[MarkerFields]) const </td></tr>
<tr class="separator:ae571daade7e16b5cb436a677ef7e2e0a inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059a9c404f886d00fecd580df5534dab inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a059a9c404f886d00fecd580df5534dab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMarkerSpace</b> (<a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a> source[MarkerFields]) const </td></tr>
<tr class="separator:a059a9c404f886d00fecd580df5534dab inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3cba66241f06792ef848b07b755508 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe3cba66241f06792ef848b07b755508"></a>
__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>LocalID</b> () const </td></tr>
<tr class="separator:abe3cba66241f06792ef848b07b755508 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c453aa013219304225d6d98fe84cab4 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c453aa013219304225d6d98fe84cab4"></a>
<a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Storage.html#a3c453aa013219304225d6d98fe84cab4">DataLocalID</a> () const </td></tr>
<tr class="memdesc:a3c453aa013219304225d6d98fe84cab4 inherit pub_methods_classINMOST_1_1Storage"><td class="mdescLeft">&#160;</td><td class="mdescRight">This number is guaranteed to be between 0 and Mesh::NumberOf(type of element) after Mesh::ReorderEmpty. <br/></td></tr>
<tr class="separator:a3c453aa013219304225d6d98fe84cab4 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a725fd1d76cc5b7b8098080692c8ff inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75a725fd1d76cc5b7b8098080692c8ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValid</b> () const </td></tr>
<tr class="separator:a75a725fd1d76cc5b7b8098080692c8ff inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17995aa90731fae234cb2897a52ce824 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17995aa90731fae234cb2897a52ce824"></a>
__INLINE <a class="el" href="classINMOST_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMeshLink</b> () const </td></tr>
<tr class="separator:a17995aa90731fae234cb2897a52ce824 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79e3f3664b2ff21892f37bce0caa0e0 inherit pub_methods_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac79e3f3664b2ff21892f37bce0caa0e0"></a>
__INLINE HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>GetHandle</b> () const </td></tr>
<tr class="separator:ac79e3f3664b2ff21892f37bce0caa0e0 inherit pub_methods_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8f9d7e81c502fc9e03c6cfa60452a28d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#a8f9d7e81c502fc9e03c6cfa60452a28d">Initialize</a> (int *argc, char ***argv)</td></tr>
<tr class="memdesc:a8f9d7e81c502fc9e03c6cfa60452a28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial initialization.  <a href="#a8f9d7e81c502fc9e03c6cfa60452a28d">More...</a><br/></td></tr>
<tr class="separator:a8f9d7e81c502fc9e03c6cfa60452a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf6bb86a72902ecc3d3442b059f2b10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadf6bb86a72902ecc3d3442b059f2b10"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classINMOST_1_1Mesh.html#aadf6bb86a72902ecc3d3442b059f2b10">Finalize</a> ()</td></tr>
<tr class="memdesc:aadf6bb86a72902ecc3d3442b059f2b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalizes operation with MPI, recomended to call, otherwise MPI may produce warnings. <br/></td></tr>
<tr class="separator:aadf6bb86a72902ecc3d3442b059f2b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:a6c89e8450f65055147301406d7f9c437 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c89e8450f65055147301406d7f9c437"></a>
typedef chunk_array<br class="typebreak"/>
&lt; INMOST_DATA_ENUM_TYPE, <br class="typebreak"/>
chunk_bits_empty &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>empty_data</b></td></tr>
<tr class="separator:a6c89e8450f65055147301406d7f9c437 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7915f5a3e87fe36e14e9766d1437369 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7915f5a3e87fe36e14e9766d1437369"></a>
typedef chunk_array&lt; <a class="el" href="classINMOST_1_1Tag.html">Tag</a>, <br class="typebreak"/>
chunk_bits_tags &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tag_array_type</b></td></tr>
<tr class="separator:ab7915f5a3e87fe36e14e9766d1437369 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5a035bf2ee39c0fb8417b0b290a26b inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc5a035bf2ee39c0fb8417b0b290a26b"></a>
typedef chunk_bulk_array<br class="typebreak"/>
&lt; chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dense_sub_type</b></td></tr>
<tr class="separator:acc5a035bf2ee39c0fb8417b0b290a26b inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac573af6facd80a651b3496938235130e inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac573af6facd80a651b3496938235130e"></a>
typedef chunk_array<br class="typebreak"/>
&lt; dense_sub_type, <br class="typebreak"/>
chunk_bits_dense_array &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dense_data_array_type</b></td></tr>
<tr class="separator:ac573af6facd80a651b3496938235130e inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580e8cfe488c581a007d7108a27d5718 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a580e8cfe488c581a007d7108a27d5718"></a>
typedef array&lt; <a class="el" href="structINMOST_1_1TagManager_1_1sparse__sub__record.html">sparse_sub_record</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_sub_type</b></td></tr>
<tr class="separator:a580e8cfe488c581a007d7108a27d5718 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d8c18c51b82ff914061a3a13b16444 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36d8c18c51b82ff914061a3a13b16444"></a>
typedef chunk_array<br class="typebreak"/>
&lt; sparse_sub_type, <br class="typebreak"/>
chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_data_array_type</b></td></tr>
<tr class="separator:a36d8c18c51b82ff914061a3a13b16444 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516013a33fc678ce51ee7a9566ffc9b inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6516013a33fc678ce51ee7a9566ffc9b"></a>
typedef chunk_array<br class="typebreak"/>
&lt; INMOST_DATA_INTEGER_TYPE, <br class="typebreak"/>
chunk_bits_elems &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>back_links_type</b></td></tr>
<tr class="separator:a6516013a33fc678ce51ee7a9566ffc9b inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083c5b8cf529631c183d8663e69e6527 inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a083c5b8cf529631c183d8663e69e6527"></a>
typedef tag_array_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>tag_iterator</b></td></tr>
<tr class="separator:a083c5b8cf529631c183d8663e69e6527 inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ab39af175e4d73ca4b9a9a7915401a inherit pro_types_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84ab39af175e4d73ca4b9a9a7915401a"></a>
typedef <br class="typebreak"/>
tag_array_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>tag_const_iterator</b></td></tr>
<tr class="separator:a84ab39af175e4d73ca4b9a9a7915401a inherit pro_types_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:a74c7e50f03649a1b5041f524d0421079 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74c7e50f03649a1b5041f524d0421079"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TagManager</b> (const <a class="el" href="classINMOST_1_1TagManager.html">TagManager</a> &amp;other)</td></tr>
<tr class="separator:a74c7e50f03649a1b5041f524d0421079 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab128149e17df47b9ebfdb8c4997a46c4 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab128149e17df47b9ebfdb8c4997a46c4"></a>
<a class="el" href="classINMOST_1_1TagManager.html">TagManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classINMOST_1_1TagManager.html">TagManager</a> const &amp;other)</td></tr>
<tr class="separator:ab128149e17df47b9ebfdb8c4997a46c4 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a6f61fd31686e47ddda096cd5a458b inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60a6f61fd31686e47ddda096cd5a458b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReallocateData</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, INMOST_DATA_INTEGER_TYPE etypenum, INMOST_DATA_ENUM_TYPE new_size)</td></tr>
<tr class="separator:a60a6f61fd31686e47ddda096cd5a458b inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397a04c1c4545b1152a438acc432f952 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a397a04c1c4545b1152a438acc432f952"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReallocateData</b> (INMOST_DATA_INTEGER_TYPE etypenum, INMOST_DATA_ENUM_TYPE new_size)</td></tr>
<tr class="separator:a397a04c1c4545b1152a438acc432f952 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7825981150daf50fb56d4f189e7c4e inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c7825981150daf50fb56d4f189e7c4e"></a>
__INLINE sparse_sub_type const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSparseData</b> (int etypenum, int local_id) const </td></tr>
<tr class="separator:a3c7825981150daf50fb56d4f189e7c4e inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95230b841496e62ea1a645b3d1336ce inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab95230b841496e62ea1a645b3d1336ce"></a>
__INLINE sparse_sub_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSparseData</b> (int etypenum, int local_id)</td></tr>
<tr class="separator:ab95230b841496e62ea1a645b3d1336ce inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029c2b2db435c0d325eb272b598816d6 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a029c2b2db435c0d325eb272b598816d6"></a>
__INLINE dense_sub_type const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDenseData</b> (int pos) const </td></tr>
<tr class="separator:a029c2b2db435c0d325eb272b598816d6 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98cc766513cd82c1f0a99c78c5b8528 inherit pro_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af98cc766513cd82c1f0a99c78c5b8528"></a>
__INLINE dense_sub_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDenseData</b> (int pos)</td></tr>
<tr class="separator:af98cc766513cd82c1f0a99c78c5b8528 inherit pro_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:a3646206503d7c8bc5a7d1ab2f2550798 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3646206503d7c8bc5a7d1ab2f2550798"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyData</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, void *adata, const void *bdata)</td></tr>
<tr class="separator:a3646206503d7c8bc5a7d1ab2f2550798 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41305bccd3e4be8bfd5ff0b8246c807 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa41305bccd3e4be8bfd5ff0b8246c807"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>DestroyVariableData</b> (const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;t, void *adata)</td></tr>
<tr class="separator:aa41305bccd3e4be8bfd5ff0b8246c807 inherit pro_static_methods_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classINMOST_1_1TagManager"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classINMOST_1_1TagManager')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a></td></tr>
<tr class="memitem:ac92171533d42711a11684c52f6dfa737 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac92171533d42711a11684c52f6dfa737"></a>
tag_array_type&#160;</td><td class="memItemRight" valign="bottom"><b>tags</b></td></tr>
<tr class="separator:ac92171533d42711a11684c52f6dfa737 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f6cb319ebef941d38a8e2c8f17db94 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6f6cb319ebef941d38a8e2c8f17db94"></a>
empty_data&#160;</td><td class="memItemRight" valign="bottom"><b>empty_dense_data</b></td></tr>
<tr class="separator:ac6f6cb319ebef941d38a8e2c8f17db94 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf73c1edda087f369ef969b64e6d9a1 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaf73c1edda087f369ef969b64e6d9a1"></a>
dense_data_array_type&#160;</td><td class="memItemRight" valign="bottom"><b>dense_data</b></td></tr>
<tr class="separator:abaf73c1edda087f369ef969b64e6d9a1 inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fada89bccb1b59070868d0509cf70e inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4fada89bccb1b59070868d0509cf70e"></a>
sparse_data_array_type&#160;</td><td class="memItemRight" valign="bottom"><b>sparse_data</b> [6]</td></tr>
<tr class="separator:ad4fada89bccb1b59070868d0509cf70e inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9676936366e5777fa061e22ea6672ca inherit pro_attribs_classINMOST_1_1TagManager"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9676936366e5777fa061e22ea6672ca"></a>
back_links_type&#160;</td><td class="memItemRight" valign="bottom"><b>back_links</b> [6]</td></tr>
<tr class="separator:aa9676936366e5777fa061e22ea6672ca inherit pro_attribs_classINMOST_1_1TagManager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classINMOST_1_1Storage"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classINMOST_1_1Storage')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classINMOST_1_1Storage.html">INMOST::Storage</a></td></tr>
<tr class="memitem:a3a9a0f8e226821c92b8e5c253e4474be inherit pro_attribs_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a9a0f8e226821c92b8e5c253e4474be"></a>
HandleType&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b></td></tr>
<tr class="separator:a3a9a0f8e226821c92b8e5c253e4474be inherit pro_attribs_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2ee75267f3c967db30b79558360a5 inherit pro_attribs_classINMOST_1_1Storage"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14f2ee75267f3c967db30b79558360a5"></a>
HandleType *&#160;</td><td class="memItemRight" valign="bottom"><b>handle_link</b></td></tr>
<tr class="separator:a14f2ee75267f3c967db30b79558360a5 inherit pro_attribs_classINMOST_1_1Storage"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1f53070855f3503b2f4cefc16cedd6a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ApplyModification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After this function any link to deleted element will be replaced by InvalidHandle(). </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>TODO:<ol type="1">
<li>maybe instead of forming set of deleted elements and subtracting set from other sets it is better to remove each modified element (done, check and compare)</li>
<li>parent/child elements in set would not be replaced or reconnected, this may lead to wrong behavior (done, check and compare) </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae39e30b11f35de81d2a9b8451ef87391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::AssignGlobalID </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign unique numbers to elements. </p>
<p>Internally this will create Mesh::GlobalIDTag and make call to Element::GlobalID and <a class="el" href="classINMOST_1_1Mesh.html#ab9f84a185381a0096fc358e7e2ff5db7" title="Retrieve global id of the element with right of modification (dangerous to modify). ">Mesh::GlobalID</a> functions valid. Internally this will also set have_global_id variable that will indicate that all the comparisons in parallel algorithms should be performed using global identificators instead of centroids which is faster.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>TODO<ol type="1">
<li>invoking function before loading mesh will not renew global identificators after load but would not unset have_global_id either. There are probably too many places when global ids may become invalid but no flag will be set. It may be benefitial to set such flags along with updating geometrical data which seems to be maintained fairly well during mesh modification </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2922f80c6c522500a887fe115cf5271d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE iteratorTag INMOST::Mesh::BeginTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first tag defined on the mesh. </p>
<p>For safety while iterating through tags you should check for validity of the tag </p>
<dl class="section return"><dt>Returns</dt><dd>first tag </dd></dl>

</div>
</div>
<a class="anchor" id="a55549e9d46cd92e2f3122e1516f3c9fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopologyCheck INMOST::Mesh::BeginTopologyCheck </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function allows you to perform some topologycal checks before you create an element. </p>
<p>Function is used internally by CreateEdge, CreateFace, CreateCell functions If you perform topological checks on your own, you'd probably better turn off checks before calling CreateXXX functions. Note that check for duplicates within mesh is performed by <a class="el" href="classINMOST_1_1Mesh.html#a116f510afe89689b615fa73b29bc6f59" title="Retrieve upper adjacent that is shared by multiple lower adjacencies. ">Mesh::FindSharedAdjacency</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>TODO: list checks performed inside in description </dd></dl>

</div>
</div>
<a class="anchor" id="a9df5a8793e5cd8e38182de107d381d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&amp; INMOST::Mesh::Bulk </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference in inner representation to the first element of array of bytes. </p>
<p>Future recomendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae496bab413c4a6103ee62ae3903e95fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a> INMOST::Mesh::BulkArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of bytes. </p>
<p>If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly sparse or dense on elements you access then it is faster to use variants of this function with hint data structure.</p>
<p>Array data structure is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53d63f6a251db48695306180f22ff67e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a> INMOST::Mesh::BulkArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of bytes in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set), likely to result in segfault.</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a042974abc70e48b9dc84714ca1a50655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a6e49b2a38cb55dd59529bd23e8b1b852">bulk_array</a> INMOST::Mesh::BulkArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of bytes in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88229181252531147051badf5a05e263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&amp; INMOST::Mesh::BulkDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of constant size array of bytes. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35a62a1c63ac51297dddabb1312f32d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&amp; INMOST::Mesh::BulkDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of bytes. </p>
<p>Future recomendation: If array was not allocated then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>TagDenseVariable </dd></dl>

</div>
</div>
<a class="anchor" id="a887f25126d7a0fc38e238e5c2b033d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ComputeGeometricType </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recompute geometrical type of current element and set it to element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d860dda768f1d8b7a1b5cd2066cb504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MarkerType INMOST::Mesh::CreateMarker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate new marker. </p>
<p>Assert will fire in debug mode (NDEBUG not set) if you run out of space for markers, in this case you either use too many markers, then you can just increase MarkerFields variable (increasing by 1 gives you 8 more markers) or you forget to release markers after you use them.</p>
<p>In release mode (NDEBUG is set) if you run out of space for markers function will return InvalidMarker() </p>
<dl class="section return"><dt>Returns</dt><dd>new marker or InvalidMarker(), see description </dd></dl>

</div>
</div>
<a class="anchor" id="a2edad518a07d8d9cfadf7803553a4991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Node.html">Node</a> INMOST::Mesh::CreateNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> *&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create node by given coordinates. </p>
<p>This operation would not involve searching existing nodes for node with the same coordinates. It is potentially dangerous to have nodes whose coordinates differ by less then GetEpsilon since ResolveShared algorithm would not know how to resolve parallel statuses of the elements. However this may be subject to change, if ResolveShared algorithm will be rewritten to resolve cells first by their centroids and only then resolve all the rest elements by adjacency information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>array of coordinates at least of size <a class="el" href="classINMOST_1_1Mesh.html#ae7b7567174f1da1fe8317eb8bb1fdc6c" title="Get number of dimensions of mesh. ">GetDimensions()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interface to created node </dd></dl>

</div>
</div>
<a class="anchor" id="a02d7bfbdaa069199d3f8b3c3e9e7f151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Tag.html">Tag</a> INMOST::Mesh::CreateTag </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>sparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INMOST_DATA_ENUM_TYPE&#160;</td>
          <td class="paramname"><em>size</em> = <code>ENUMUNDEF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the tag by name, type and size. </p>
<p>You cannot create the tag with the same name and different type or size.</p>
<p>You may make subsequent calls to the function with the same name, same type and same size (or undefined size, then it will be deduced) but different selection of element.</p>
<p>The following recomendation is for future: When you create data of variable size, every array of data for every element will be empty at first, so before accessing it through mechanism for single-valued data (Real, Integer, Bulk, Reference) you should first resize arrays otherwise your program very likely to be halted by segmentation fault. For this case arrays are not allocated automatically from performance considerations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the tag </td></tr>
    <tr><td class="paramname">dtype</td><td>type of the tag </td></tr>
    <tr><td class="paramname">etype</td><td>the selection of elements on which the data of the tag is defined, you may use bitwise or operations to define tag on multiple types of elements, example CELL | FACE </td></tr>
    <tr><td class="paramname">sparse</td><td>the selection of elements from etype on which the tag is sparse, for example, if you know that the data is used on all cells and only on boundary faces, then you may should set etype = CELL | FACE and sparse = FACE </td></tr>
    <tr><td class="paramname">size</td><td>size of associated data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the tag that represents the data </dd></dl>

</div>
</div>
<a class="anchor" id="a2078f4c2589dc14fe6291416ac21050f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::DataLocalID </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve position of the data position of current element. </p>
<p>After ReorderEmpty this number is guaranteed to be between 0 and NumberOf(type of element) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>local id of data </dd></dl>

</div>
</div>
<a class="anchor" id="afab20c754eef0006e3085dc546e893bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::DelData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove tag data from given element. </p>
<p>Removes data of variable size and sparse tag data. Clears to zero data of fixed size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abac72292a681f80f9f112566e3c04bc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::DelDenseData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes data of variable size, clears to zero data of fixed size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a569c516120df121980d0585deadd3634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Delete </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will hide element in modification state (between BeginModification and EndModification) or call Destroy in non-modification state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if true then element was deleted, otherwise it was hidden </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1" title="Hide element from mesh. ">Mesh::Hide</a> </dd>
<dd>
Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0" title="Completely destroy element from mesh. ">Mesh::Destroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae43e132d6fd14903e263f00fbcffec51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Tag.html">Tag</a> INMOST::Mesh::DeleteTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em> = <code>NODE|EDGE|FACE|CELL|ESET|MESH</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the data that is represented by the tag from elements of selected type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
    <tr><td class="paramname">mask</td><td>the selection of the elements on which the data should be removed, may be set by bitwise or operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns tag that returns false on isValid() request if all the data was removed and the tag is no more occupied, otherwise returns the tag </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Tag::isValid </dd></dl>

<p>Reimplemented from <a class="el" href="classINMOST_1_1TagManager.html">INMOST::TagManager</a>.</p>

</div>
</div>
<a class="anchor" id="a21517e19d638410e9a5bdbaf4cc8fd4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::DelSparseData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes data of variable size and sparse tag data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e2c090ee95e802c4f486a5d98fc6cb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Destroy </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completely destroy element from mesh. </p>
<p>This function bypass check that mesh is in modification state and will remove element immediatly. It will disconnect element from lower adjacencies and delete all the upper adjacencies that depend on current element. If you don't want upper adjacencies to be deleted you should first use Element::Disconnect function to explicitly disconnect current element and then destroy it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>Element::Disconnect </dd></dl>

</div>
</div>
<a class="anchor" id="ae69466c97ab50182ba143df2a76d5d9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE iteratorTag INMOST::Mesh::EndTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the indicator for loop to end iteration over tags. </p>
<dl class="section return"><dt>Returns</dt><dd>the inexistant tag that is located the one position after the last tag </dd></dl>

</div>
</div>
<a class="anchor" id="a1c6c26bcbe6e7a0cba093c0b8312ba04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopologyCheck INMOST::Mesh::EndTopologyCheck </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function performs some topologycal checks after creation of element. </p>
<p>Function is used internally by CreateEdge, CreateFace, CreateCell functions.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>TODO: list checks performed inside in description. </dd></dl>

</div>
</div>
<a class="anchor" id="a9787ba8c75b41b76b89aeeae2e8aefad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Enumerate </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Tag.html">Tag</a>&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all elements begining with start and put numeration to data associated with num_tag for all elements with given type mask. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>bitwise or of types of elements </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc8c51bea6707ccedc76dba47ea0d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Enumerate </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all elements begining with start and put numeration to data associated with num_tag. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>array of handles </td></tr>
    <tr><td class="paramname">num</td><td>number of handles </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a class="anchor" id="a92e7888589b79355fa273ad67c8c9bb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Enumerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1ElementArray.html">ElementArray</a>&lt; EType &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate all elements begining with start and put numeration to data associated with num_tag. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elements</td><td>array of elements </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a class="anchor" id="a0239ff055f17c76ba19ef8a169b14962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::EnumerateSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>num_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>define_sparse</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all elements in the set. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>handle of the set </td></tr>
    <tr><td class="paramname">num_tag</td><td>a tag that is associated with the data </td></tr>
    <tr><td class="paramname">start</td><td>starting value for enumeration </td></tr>
    <tr><td class="paramname">define_sparse</td><td>if true then function will define sparse data on elements that don't have it, otherwise it will skip those elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>last value on all the processors </dd></dl>

</div>
</div>
<a class="anchor" id="aa3e1067bc3139bb0216f7ce3c1936734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update data from Shared elements to Ghost elements. </p>
<p>For backward direction please see <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements. ">Mesh::ReduceData</a>. If you have a tag of DATA_BULK type and you store your own custom data structure in it, it is highly recomended that you provide MPI information about your structure through Tag::SetBulkDataType, this would not do any difference on homogeneous architecture, but it may help you save a lot of time and nerves in heterogeneous parallel environment.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>TODO: see TODO in <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements. ">Mesh::ReduceData</a></dd></dl>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements. ">Mesh::ReduceData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a064ee931e0f6a75dae38a65d3e8603af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeData </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will perform exchange of multiple data tags. </p>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35ca81c3d8a01aa6a9ce983769fa03cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous synchronization of data. </p>
<p>You should define object of type <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> that will hold temporary buffers for data. every <a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data. ">Mesh::ExchangeDataBegin</a> should be matched with <a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data. ">Mesh::ExchangeDataEnd</a> with the same <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object. After matching <a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data. ">Mesh::ExchangeDataEnd</a> the <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object may be reused If you will go out of the scope where <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object was defined it will be deallocated and may result in segmentation fault.</p>
<p>You should also never put the same <a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> object to any other <a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data. ">Mesh::ExchangeDataBegin</a> or <a class="el" href="classINMOST_1_1Mesh.html#a0597bf77b8438dc79bf791912a2b34d2" title="This function intializes data reduction. ">Mesh::ReduceDataBegin</a>, until matching <a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data. ">Mesh::ExchangeDataEnd</a> because it may override or reallocate buffers, internally used by MPI and remote processor will receive garbage instead of data.</p>
<p>Nonblocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a443828dada7d0fe8ebcf8040593e1ac1" title="Complete asynchronous synchronization of data. ">Mesh::ExchangeDataEnd</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a418d72493b24344d247b811bd980b3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataBegin </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize exchange of multiple data tags. </p>
<p>Using this function may lead to good overlapping between communication and computation.</p>
<p>Nonblocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a443828dada7d0fe8ebcf8040593e1ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete asynchronous synchronization of data. </p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data. ">Mesh::ExchangeDataBegin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa49bac8c58e4e610eb4c7ec7dd9f4b96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeDataEnd </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will finalize exchange of multiple data tags. </p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2f72e7c09e74aa9962721646a627650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeGhost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>bridge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Form several layers of ghosted cells that are adjacent through bridge elements to current cells. </p>
<p>This function acceptes any mesh topology, failure on some mesh should be considered a bug and sample example should be provided for testing purposes.</p>
<p>This function internally calculates layer by layer and invokes ExchangeMarked for each layer, you can either reproduce the algorithm on your own if you want to bypass the function and call <a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a" title="This function realizes two algorithms: ghosting of elements and migration of elements. ">Mesh::ExchangeMarked</a> directly, but then you will lose optimization in <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. ">Mesh::Redistribute</a>, that expects that layers are formed the same way they are formed in <a class="el" href="classINMOST_1_1Mesh.html#ad2f72e7c09e74aa9962721646a627650" title="Form several layers of ghosted cells that are adjacent through bridge elements to current cells...">Mesh::ExchangeGhost</a>. Internally it sets up LayersTag and BridgeTag for the mesh with provided values, which are used by <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. ">Mesh::Redistribute</a> but you are discouraged to override these tags since using non-matching algorithms is not tested and should be considered dangerous.</p>
<p>Nevertheless you can use this function first for layers then request any additional ghosted elements by ExchangeMarked.</p>
<p>Collective point-2-point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layers</td><td>number of required layers of ghosted elements </td></tr>
    <tr><td class="paramname">bridge</td><td>bitwise mask of elements for which neighbouring cells should be considered a layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a" title="This function realizes two algorithms: ghosting of elements and migration of elements. ">Mesh::ExchangeMarked</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. ">Mesh::Redistribute</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae44b9cfcb8964acbd710562df331a51a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ExchangeMarked </td>
          <td>(</td>
          <td class="paramtype">enum Action&#160;</td>
          <td class="paramname"><em>action</em> = <code>AGhost</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function realizes two algorithms: ghosting of elements and migration of elements. </p>
<p>ghosting:</p>
<p>Creates ghosted elements at other processors prescribed in SendtoTag() performs sending and receiving of elements and all operations to keep parallel state of the mesh.</p>
<p>Given that all the data was up to date among processors all the data at the end of the algorithm will be also up to data</p>
<p>migration:</p>
<p>To correctly perform migration of elements it is necessery to set up tags besides SendToTag(), which indicates to where every element should be sent:</p>
<ul>
<li>tag "TEMPORARY_NEW_PROCESSORS", of type DATA_INTEGER with variable size, tells which processors will have copy of the element after migration;</li>
<li>tag "TEMPORARY_NEW_OWNER", of type DATA_INTEGER of size 1, tells which processor will have main copy of the element.</li>
</ul>
<p>if there is no current processor in "TEMPORARY_NEW_PROCESSORS", then current processor will remove copy of the element. All this actions are performed automatically by <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. ">Mesh::Redistribute</a> based on information provided in <a class="el" href="classINMOST_1_1Mesh.html#a1cd4e1b35b122a5cfc24d6d74229b81b" title="Don&#39;t put this shortcut to any function directly, as it creates tag inside assign to other object of ...">Mesh::RedistributeTag</a> which effectively contains new owner.</p>
<p>Given that all the data was up to date among processors all the data at the end of the algorithm will be also up to data</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>TODO<ol type="1">
<li>test halo exchange algorithm (if used then change collective point-2-point to collective)</li>
<li>see TODO 2 in <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. ">Mesh::Redistribute</a></li>
</ol>
</dd></dl>
<p>Collective point-2-point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>Mesh::SendtoTag </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. ">Mesh::Redistribute</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ac1be80eb3f359e6d2834f212131200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::ExclusiveSum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute sum of integer values for all processors with rank lower then current, excluding current processor. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>value on current processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>described sum </dd></dl>

</div>
</div>
<a class="anchor" id="a116f510afe89689b615fa73b29bc6f59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HandleType INMOST::Mesh::FindSharedAdjacency </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve upper adjacent that is shared by multiple lower adjacencies. </p>
<dl class="section return"><dt>Returns</dt><dd>handle of found element or InvalidHandle() </dd></dl>

</div>
</div>
<a class="anchor" id="abd9c22bde076d9828752924f1b6cefb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::GetData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy inner data array of size elements to provided array begining from shift element. </p>
<p>It is assumed that user-provided array don't overlap inner data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">shift</td><td>for which element to start to copy </td></tr>
    <tr><td class="paramname">size</td><td>how many elements to copy </td></tr>
    <tr><td class="paramname">data</td><td>user-provided array where data should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a721e7a76dba9bc87c4f014bff013cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INMOST_DATA_ENUM_TYPE INMOST::Mesh::GetDataSize </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of the array. </p>
<p>For variable size arrays returns current size of the array. For constant size array returns the same value that may be obtained through GetSize. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>Mesh::GetSize </dd></dl>

</div>
</div>
<a class="anchor" id="ae7b7567174f1da1fe8317eb8bb1fdc6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE <a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::GetDimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of dimensions of mesh. </p>
<p>Size of the array returned by Node::Coords will match this number. </p>
<dl class="section see"><dt>See Also</dt><dd>Node::Coords </dd></dl>

</div>
</div>
<a class="anchor" id="a3651c7afd0489bd19eb83554b63d3a31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE <a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> INMOST::Mesh::GetEpsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve tolerance for coordinates comparison. </p>
<dl class="section return"><dt>Returns</dt><dd>real value </dd></dl>

</div>
</div>
<a class="anchor" id="a1b5d5a48564cae0b29d152cc40673632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string INMOST::Mesh::GetFileOption </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current option corresponding to key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>options for which options should be retrieven </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c8a00522e2b06a0b59e25cae119a237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::GetMarker </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check weather the marker is set one the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">n</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7db80997803b96df82f83c4e53f64ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::GetMarkerSpace </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&#160;</td>
          <td class="paramname"><em>copy</em>[MarkerFields]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a copy of the bytes that store markers on the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">copy</td><td>storage to put data to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f707f8ed964b9ff6e143a625e193823"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE MeshState INMOST::Mesh::GetMeshState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get parallel state of the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>either Mesh::Serial or Mesh::Parallel </dd></dl>

</div>
</div>
<a class="anchor" id="a7a8d32b876d5299b4da51de0f5f5386a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int INMOST::Mesh::GetParallelFileStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve currently set parallel strategy for ".pmf" files. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a8543798618f286ce2af5ca2d5a0d7b87" title="Retrieve currently set parallel strategy. ">Mesh::GetParallelStrategy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8543798618f286ce2af5ca2d5a0d7b87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int INMOST::Mesh::GetParallelStrategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve currently set parallel strategy. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#adc92ee8e1fc34b3f3a41f2a1984ab6f2" title="Set parallel strategy for inner communications. ">Mesh::SetParallelStrategy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5223aa8af17d63c7be40027ff789df7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> INMOST::Mesh::GetSet </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve set by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>set name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set whose name match or InvalidHandle() </dd></dl>

</div>
</div>
<a class="anchor" id="a94963a0f3f1d80ee0785fb8ebd409339"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element::Status INMOST::Mesh::GetStatus </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve parallel status of the element. </p>
<p>If mesh is in Serial state then call always returns Element::Owned. otherwise it will return:</p>
<ul>
<li>Element::Owned if there is a single copy of the element on the current processor</li>
<li>Element::Shared if the main copy of the element is located on the current processor</li>
<li>Element::Ghost if current processor stores dependent copy of the element <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Element::Status, see function description </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ab9f84a185381a0096fc358e7e2ff5db7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::GlobalID </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve global id of the element with right of modification (dangerous to modify). </p>
<p>Run AssignGlobalID so that tag is automatically allocated and shortcut is set within mesh, otherwise tag is not created and call will fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global id </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391" title="Assign unique numbers to elements. ">Mesh::AssignGlobalID</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1c43e6d9cb856c240f084b2f839c2c8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::GlobalID </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve global id of the element without right of modification. </p>
<p>Run AssignGlobalID so that tag is automatically allocated and shortcut is set within mesh, otherwise tag is not created and call will fail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global id </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#ae39e30b11f35de81d2a9b8451ef87391" title="Assign unique numbers to elements. ">Mesh::AssignGlobalID</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a14fe30c96eba52f03de5780503116af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::HaveData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether data is present on given element. </p>
<p>Always returns true for dense tag data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle to the element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that indicates data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if data exists otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a632e8966cbebd2e82df1edc7474a5993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Hidden </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether element is hidden. </p>
<dl class="section return"><dt>Returns</dt><dd>true if hidden </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1" title="Hide element from mesh. ">Mesh::Hide</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2b3eaaadcd233cf11deba24d1fd64ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Hide </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hide element from mesh. </p>
<p>All the functions (except direct access like LowConn,HighConn or ElementSet::getElementsHandles) involving adjacencies retrival would not return this element. Works only inside BeginModification and EndModification, on EndModification all Hidden elements are destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if true then element was hidden </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd></dl>

</div>
</div>
<a class="anchor" id="a1e7462d775868bb6ef687cef8a5198cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element::adj_type&amp; INMOST::Mesh::HighConn </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access directly higher order adjacencies of current element with right of modification. </p>
<p>This function gives direct access to elements and allows you to overwrite handles which is not recomended. You bypass topology checks, correct connectivity estableshment and geometric data updates. If you do so then check connectivity afterwards by Element::CheckElementConnectivity for debugging purposes. Then for correct function of geometrical algorithms in order from lower modified adjacenices to upper modified adjacencies (if some element have lower adjacencies updated then it should be updated otherwise it shouldn't) call ComputeGeometricType to deduce geometric representation or force it by SetGeometricType, then for element of type CELL call RestoreCellNodes, clear current mutual connection to the nodes and establish new mutual connections from nodes returned by RestoreCellNodes; then for all elements call RecomputeGeometricData to automatically recompute all geometric quantities. Don't forget that edges of the face should be ordered for correct retrival of nodes, otherwise <a class="el" href="classINMOST_1_1Face.html#a102ef5504795e2b3607093071259397e" title="Retrieve all the nodes of the element. ">Face::getNodes</a> and <a class="el" href="classINMOST_1_1Element.html#a00696ff8cd77491e1c4307cae166e92d" title="Retrieve all the nodes of the element. ">Element::getNodes</a> for FACE in 3 dimensions or <a class="el" href="classINMOST_1_1Cell.html#acc265095375df199a083a344d56e4645" title="Retrieve all the nodes of the element. ">Cell::getNodes</a> and <a class="el" href="classINMOST_1_1Element.html#a00696ff8cd77491e1c4307cae166e92d" title="Retrieve all the nodes of the element. ">Element::getNodes</a> for CELL in 2 dimensions will return garbage</p>
<ul>
<li>For NODE this returns edges that are connected to this node;</li>
<li>For EDGE this returns faces that are connected to this edge;</li>
<li>For FACE this returns cells that are connected to this face</li>
<li>For CELL this returns nodes of the cell</li>
<li>For ESET first three entries are parent, sibling, child then records represent empty positions in LowConn</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see description </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Element::CheckElementConnectivity </dd>
<dd>
<a class="el" href="classINMOST_1_1Element.html#a96bd136b0f249c958fc8632553aa3b58" title="Connects lower adjacencies to current element, geometric data and cell nodes are updated automaticall...">Element::Connect</a> </dd>
<dd>
Element::Disconnect </dd>
<dd>
Mesh::SetGeometricType </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a887f25126d7a0fc38e238e5c2b033d58" title="Recompute geometrical type of current element and set it to element. ">Mesh::ComputeGeometricType</a> </dd>
<dd>
Mesh::RestoreCellNodes </dd>
<dd>
Mesh::RecomputeGeometricData </dd>
<dd>
Face::FixNormalOrientation </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ad20f64a301adf9c3fafe28a8f921a791" title="Access directly lower order adjacencies of current element with right of modification. ">Mesh::LowConn</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f9d7e81c502fc9e03c6cfa60452a28d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void INMOST::Mesh::Initialize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initial initialization. </p>
<p>Calls MPI_Initialize, if MPI was not initialized it is necessery to invoke this function if you plan to use any parallel algorithms Accepts arguments passed to console aplication or NULL </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>number of arguments for command line </td></tr>
    <tr><td class="paramname">argv</td><td>strings of arguments of command line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9d44832b3e826a2b61c8e91c5457fbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::Integer </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of integer values. </p>
<p>Future recomendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0bbbfafae1405bd27b726bdbb4c2cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a> INMOST::Mesh::IntegerArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of integer values. </p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function. variants of this function with hint data structure.</p>
<p>Array data structure is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d5351b2b6e7f7824598cb46b3c35118"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a> INMOST::Mesh::IntegerArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of integer values in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set), likely to result in segfault.</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad74aed700689551567039dfddfbf5971"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a4d1637367f0487eb778894b57fc94647">integer_array</a> INMOST::Mesh::IntegerArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of integer values in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dd3068d4db02871478bea86fce38945"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::IntegerDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of integer values. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af20ebec0bab305054c5960d7683bfcfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&amp; INMOST::Mesh::IntegerDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of integer values. </p>
<p>Future recomendation: If array was not allocated then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab90d3db6596d5de6f7ddfd7f72af600f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate real value over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>value on current processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum over all processors </dd></dl>

</div>
</div>
<a class="anchor" id="a541bea07883f3afa0be27748edb479ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate integer value over all processors. </p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>on current processor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum over all processors </dd></dl>

</div>
</div>
<a class="anchor" id="abb1eacb17ae889557d9d9d32d7b61ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a> INMOST::Mesh::Integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate data corresponding to tag between all processors. </p>
<p>Elements without the data defined on them or when entry not present will be skipped.</p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>tag that correspond to data to be integrated </td></tr>
    <tr><td class="paramname">entry</td><td>in the array of data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of types of elements on which to integrate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum between all processors </dd></dl>

</div>
</div>
<a class="anchor" id="a870a18031c98f36972e6df4c21859a28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::isMeshModified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check weather code runs between Mesh::BeginModification, Mesh::EndModification scope. </p>
<p>In case mesh is modified, on element creation Mesh::TieElements will always place elements to the end of the array as a result all the newly created elements will be iterated after current or hidden elements. </p>

</div>
</div>
<a class="anchor" id="a5dfd481d638b2d2d72193b4b8fa159a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Load </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acceptable file formats for reading. </p>
<ul>
<li>".vtk" - legacy vtk format for unstructured grid</li>
<li>".pvtk" - legacy parallel vtk format</li>
<li>".gmv" - format acceptable by general mesh viewer</li>
<li>".msh" - gmsh generator format</li>
<li>".grdecl" - eclipse format (under construction)</li>
<li>".grid" - mesh format by Mohammad Karimi-Fard</li>
<li>".pmf" - internal parallel portable binary format, saves all features</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>path to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad20f64a301adf9c3fafe28a8f921a791"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element::adj_type&amp; INMOST::Mesh::LowConn </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access directly lower order adjacencies of current element with right of modification. </p>
<p>This function gives direct access to elements and allows you to overwrite handles. If you are going to overwrite them then read recomendations in description for HighConn function.</p>
<ul>
<li>For NODE this returns cells that are connected to this node;</li>
<li>For EDGE this returns nodes of the edge</li>
<li>For FACE this returns edges of the face</li>
<li>For CELL this returns faces of the cell</li>
<li>For ESET handles of the elements that this set contain <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see description </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a1e7462d775868bb6ef687cef8a5198cb" title="Access directly higher order adjacencies of current element with right of modification. ">Mesh::HighConn</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="aaa34219e9c94a2509c7bae2254ea7a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::New </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether element is new. </p>
<p>Works only in modification state (between BeginModification and EndModification), when you create elements all of them are marked. </p>
<dl class="section return"><dt>Returns</dt><dd>true if new </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd></dl>

</div>
</div>
<a class="anchor" id="a05939bf3f29697b1ffb2005a617ee585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE <a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a> INMOST::Mesh::NumberOfTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the total number of valid tags. </p>
<dl class="section return"><dt>Returns</dt><dd>returns the number of valid tags </dd></dl>

</div>
</div>
<a class="anchor" id="afa084c637bc9f6850ed77fbb7778d404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&amp; INMOST::Mesh::Real </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of real values. </p>
<p>Future recomendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a90e88bbdedcf71c3226f3dc94da66807" title="Returns a reference to inner memory location of the first element of the array of real values...">Mesh::RealDF</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a679a4a6ed4e4508126919b8fc8fea27a" title="Returns a reference in dense array to the first element of variable size array of real values...">Mesh::RealDV</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a06bdd4e7c0d26750ca0aa40e03fc7d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a> INMOST::Mesh::RealArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of real values. </p>
<p>If you know that data is certanly dense on elements you access then it is faster to use variants of this function with hint data structure.</p>
<p>Array data structure is guaranteed to be valid during mesh modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8527fa3c2f6ece108b5abce389566365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a> INMOST::Mesh::RealArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of real values in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7a5f7d22e5b9f7c01b9741719b853dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a430e5358d435befb38169beef593527e">real_array</a> INMOST::Mesh::RealArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of real values in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90e88bbdedcf71c3226f3dc94da66807"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&amp; INMOST::Mesh::RealDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to inner memory location of the first element of the array of real values. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a679a4a6ed4e4508126919b8fc8fea27a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&amp; INMOST::Mesh::RealDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of real values. </p>
<p>Future recomendation: If array was not allocated (resized) then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5691f394480da7e21c5099e313df03e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RecomputeParallelStorage </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regather ghosted and shared element sets for data exchange. </p>
<p>This function will be quite useful if you change statuses of elements or modify mesh on your own bypassing internal algorithms.</p>
<p>No action will be performed if USE_PARALLEL_STORAGE is not set in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a>, since all the elements are computed during exchange phase.</p>
<p>Generally this is not needed if you use high-level algorithms for mesh modification or mesh redistribution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>bitwise type mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>Mesh::BeginModification </dd>
<dd>
Mesh::EndModification </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ae44b9cfcb8964acbd710562df331a51a" title="This function realizes two algorithms: ghosting of elements and migration of elements. ">Mesh::ExchangeMarked</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a5cb95f1e8d6b7987496fc8276c86cf3a" title="Delete some ghost cells provided in array. ">Mesh::RemoveGhostElements</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade20ec7c8563e82bf8057bc47a3314b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Redistribute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. </p>
<p>This will perform all the actions to send mesh elements and data and reproduce new mesh partitions on remote elements and correctly resolve parallel state of the mesh. If you have priviously prescribed number of layers through ExchangeGhost, then minimal number of actions will be performed to reproduce layers of ghosted elements whithout involving removal of all ghosted elements.</p>
<p>Internally function sets up following data on elements using provided information:</p>
<ul>
<li>"TEMPORARY_NEW_PROCESSORS" - new set processors that contain copy of the element</li>
<li>"TEMPORARY_NEW_OWNER" - new owner for each processor (effectively RedistributeTag)</li>
</ul>
<p>Action of this function regarding restoration of layers of ghosted elements in the case you have modified mesh without involving <a class="el" href="classINMOST_1_1Mesh.html#a60274817b98e76ec5a411f0c3df2a76b" title="This function is not yet implemented. ">Mesh::ResolveModification</a> is yet to be tested and should be considered dangerous.</p>
<p>If you have output from Zoltan or ParMetis for cells of the mesh then just write this output to RedistributeTag and call <a class="el" href="classINMOST_1_1Mesh.html#ade20ec7c8563e82bf8057bc47a3314b7" title="Migrate all the elements to the new owners prescribed in data corresponding to RedistributeTag. ">Mesh::Redistribute</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>TODO:<ol type="1">
<li>introduce "TEMPORARY_KEEP_GHOSTED" tag that will store processors on which copy of element should be kept, internally just merge it with "TEMPORARY_NEW_PROCESSORS" tag this will allow user to control ghosting of certain elements and not to invoke ExchangeMarked every time after Redistribute. This is probably already done using Mesh::SendtoTag, because function fills it without clearing and ExchangeMarked performs initial action based on SendtoTag, it is due to check that SendtoTag is properly merged with "TEMPORARY_NEW_PROCESSORS" before call to ExchangeMarked and received elements are not deleted by accident.</li>
<li>let user provide any integer tag as input without involving RedistributeTag</li>
</ol>
</dd></dl>
<p>Collective point-2-point.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a1cd4e1b35b122a5cfc24d6d74229b81b" title="Don&#39;t put this shortcut to any function directly, as it creates tag inside assign to other object of ...">Mesh::RedistributeTag</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#ad2f72e7c09e74aa9962721646a627650" title="Form several layers of ghosted cells that are adjacent through bridge elements to current cells...">Mesh::ExchangeGhost</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1cd4e1b35b122a5cfc24d6d74229b81b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE <a class="el" href="classINMOST_1_1Tag.html">Tag</a> INMOST::Mesh::RedistributeTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Don't put this shortcut to any function directly, as it creates tag inside assign to other object of type <a class="el" href="classINMOST_1_1Tag.html">Tag</a> and put this object to functions. </p>

</div>
</div>
<a class="anchor" id="a2d488479041917c975b1e662d642c4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulation of data from ghost elements to shared elements. </p>
<p>Accumulation is performed based on user-provided function. When processor - owner of the element receives data addressed to this element then it calls user-defined op function. Since there may be multiple ghost elements per one shared element, function may be called multiple times.</p>
<p>Several examples of reduction functions may be found within the mesh_parallel.cpp source.</p>
<p>Remember that the result will be up to date only on the owner of the processor. You will have to run <a class="el" href="classINMOST_1_1Mesh.html#aa3e1067bc3139bb0216f7ce3c1936734" title="Update data from Shared elements to Ghost elements. ">Mesh::ExchangeData</a> to make the data up to date among all of the processors. If you have a tag of DATA_BULK type and you store your own custom data structure in it, it is highly recomended that you provide MPI information about your structure through Tag::SetBulkDataType, this would not do any difference on homogeneous architecture, but it may help you save a lot of time and nerves in heterogeneous parallel environment.</p>
<p>Exchanging tags of DATA_REFERNCE is not implemented, TODO 14. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>TODO:<ol type="1">
<li>Exchanging DATA_REFERENCE tags not implemented, this is due to the absence of any conclusion</li>
</ol>
<ul>
<li>on how it should behave: either only search within elements owned by the other processor and establish references and set InvalidHandle() to elements that are not found (fairly easy, will involve search operations to check against owned elements for similar entry, efficient implementation will require bounding search trees (see TODO 49);</li>
<li>or: send all the referenced elements through PackElementsData and establish all the links within elements reproduced by UnpackElementsData (UnpackElementsData calls UnpackTagData with set of unpacked elements using which it will be vary comfortable to establish references on remote processor)</li>
</ul>
</dd></dl>
<p>Blocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#aa3e1067bc3139bb0216f7ce3c1936734" title="Update data from Shared elements to Ghost elements. ">Mesh::ExchangeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a831a8bab953c4d8aa102e58bac81c25f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceData </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will perform reduction of multiple data tags. </p>
<p>Note that function will be the same for all tags, you can differentiate behavior of function depending on tag name (may be expensive).</p>
<p>Blocking, collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0597bf77b8438dc79bf791912a2b34d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function intializes data reduction. </p>
<p>Read recomendations about exchange_storage object in <a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data. ">Mesh::ExchangeDataBegin</a></p>
<p>Nonblocking, Collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements. ">Mesh::ReduceData</a> </dd>
<dd>
<a class="el" href="classINMOST_1_1Mesh.html#a35ca81c3d8a01aa6a9ce983769fa03cd" title="Start asynchronous synchronization of data. ">Mesh::ExchangeDataBegin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71c5b8a155e89d182f18e26dbe4b8670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataBegin </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will initialize reduction of multiple data tags. </p>
<p>Nonblocking, collective point-2-point</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8273226d8ab6e54baba5db22107df37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function completes data reduction. </p>
<p>Read <a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements. ">Mesh::ReduceData</a> for information about op function</p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2d488479041917c975b1e662d642c4a5" title="Accumulation of data from ghost elements to shared elements. ">Mesh::ReduceData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aabf4380aa2878e72cf399f97598dcebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReduceDataEnd </td>
          <td>(</td>
          <td class="paramtype">const tag_set &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceOperation&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Mesh_1_1exchange__data.html">exchange_data</a> &amp;&#160;</td>
          <td class="paramname"><em>storage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will finalize exchange of multiple data tags. </p>
<p>Blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>multiple tags that represents data </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or of element types </td></tr>
    <tr><td class="paramname">select</td><td>set the marker to filter elements that perform operation, set 0 to select all elements </td></tr>
    <tr><td class="paramname">storage</td><td>buffer that will temporary hold sended data </td></tr>
    <tr><td class="paramname">op</td><td>user-defined operation on received data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfa8b2f65d63edbbed90d865ab6f5314"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a>&amp; INMOST::Mesh::Reference </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference in inner representation to the first element of array of element handles. </p>
<p>Future recomendation: If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly dense and fixed or variable on elements you access then it is faster to use specialized variants of this function.</p>
<p>Reference to the data is guaranteed to be valid during mesh modification.</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html">Face</a>, <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac211da4cbe1dc33394c9b725b64b1e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a> INMOST::Mesh::ReferenceArray </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of element handles. </p>
<p>If variable size array was not allocated then this function will generate segmentation fault.</p>
<p>If you know that data is certanly sparse or dense on elements you access then it is faster to use variants of this function with hint data structure.</p>
<p>The class reference_array that is used to represent array of elements stores handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html">Face</a>, <a class="el" href="classINMOST_1_1Cell.html">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<p>Array data structure is guaranteed to be valid during mesh modification. If you delete elements by <a class="el" href="classINMOST_1_1Mesh.html#a569c516120df121980d0585deadd3634" title="This function will hide element in modification state (between BeginModification and EndModification)...">Mesh::Delete</a> or Element::Delete all the references are also will be valid and reverted to InvalidHandle on <a class="el" href="classINMOST_1_1Mesh.html#a1f53070855f3503b2f4cefc16cedd6a0" title="After this function any link to deleted element will be replaced by InvalidHandle(). ">Mesh::ApplyModification</a>. If you use <a class="el" href="classINMOST_1_1Mesh.html#a0e2c090ee95e802c4f486a5d98fc6cb0" title="Completely destroy element from mesh. ">Mesh::Destroy</a> to delete mesh elements or delete elements not within modification state then references may become either invalid but not testable against InvalidHandle (situation may be tested by Element::isValid or Mesh::isValidHandle) or reference may be reused by another element if you mix deletion and creation of elements and then is no way to resolve this situation, except if you have created only one element the it may be retrieved by Mesh::LastHandle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a class="anchor" id="a92ba4c935940111e2c9584a9cc96fe6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a> INMOST::Mesh::ReferenceArrayDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of element handles in dense array. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set), likely to result in segfault.</p>
<p>Note that as array is fixed you shouldn't use any functions that alter size of the array as resize, erase, insert, you may use replace if initial and final size will match, in debug mode assert will fire if you try to do this in release (NDEBUG is set) it will lead to segfault.</p>
<p>The class reference_array that is used to represent array of elements stores handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html">Face</a>, <a class="el" href="classINMOST_1_1Cell.html">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a class="anchor" id="aa2a8c6f6d53a863be14b2c137de4eff5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage_1_1reference__array.html">reference_array</a> INMOST::Mesh::ReferenceArrayDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array of element handles in dense array of variable size. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>The class reference_array that is used to represent array of elements stores handles inside but accessing them through square scopes [] or by arrow -&gt; in iterator will automatically form object of type <a class="el" href="classINMOST_1_1Element.html">Element</a>. If you are not sure that stored handles are valid, you should either check that by Element::isValid (involves deep check) or test handle against InvalidHandle (simple check). To obtain handle you may use reference_array::at function or dereference * operator for iterator. If you need custom object like <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html">Face</a>, <a class="el" href="classINMOST_1_1Cell.html">Cell</a> or <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> you may use Element::getAsNode, Element::getAsEdge, Element::getAsFace, Element::getAsCell and Element::getAsSet functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>InvalidHandle </dd>
<dd>
Element::isValid </dd>
<dd>
Element::getAsNode </dd>
<dd>
Element::getAsEdge </dd>
<dd>
Element::getAsFace </dd>
<dd>
Element::getAsCell </dd>
<dd>
Element::getAsSet </dd></dl>

</div>
</div>
<a class="anchor" id="ab5abf1a33ab21a0c60338a97287fc115"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a>&amp; INMOST::Mesh::ReferenceDF </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of constant size array of element handles. </p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and fixed is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html">Face</a>, <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents dense data of fixed size on given handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac87430b220565362949e68b073e07c8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#a8674802045ec170a3c9d0e3281545b54">reference</a>&amp; INMOST::Mesh::ReferenceDV </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference in dense array to the first element of variable size array of element handles. </p>
<p>Future recomendation: If array was not allocated then this function will generate segmentation fault.</p>
<p>If you don't know any hint information about tag data you should not use this function.</p>
<p>Asserts will fire in debug mode if assumption that data is dense and variable is incorrect, no checks performed in release mode (NDEBUG is set).</p>
<p>Using handle you can construct objects of type <a class="el" href="classINMOST_1_1Storage.html" title="Base class for Mesh, Element, and ElementSet classes. ">Storage</a>, <a class="el" href="classINMOST_1_1Element.html">Element</a>, <a class="el" href="classINMOST_1_1Node.html">Node</a>, <a class="el" href="classINMOST_1_1Edge.html">Edge</a>, <a class="el" href="classINMOST_1_1Face.html">Face</a>, <a class="el" href="classINMOST_1_1Cell.html">Cell</a>, <a class="el" href="classINMOST_1_1ElementSet.html">ElementSet</a> by calling their constructor with pointer to mesh and handle as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0872520e92d5fefcb827b239d23e4229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ReleaseMarker </td>
          <td>(</td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release marker back for reuse. </p>
<p>This function will only notice mesh that the marker is free to be reused, this will not clear markers from elements. Before releasing the marker you should ensure that all the marker is removed from all the elements. Since many inner algorithms use markers, not properly clearing markers from elements may lead to undefined behavior.</p>
<p>Since it is expensive to check asserts will fire in debug mode (NDEBUG not set) only if you define CHECKS_MARKERS in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a>, no checks will be performed in release mode(NDEBUG is set). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>byte position and byte bit mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa758ff129bf79eff3c446946e276006c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RemMarker </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the marker from the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">n</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14f8614996be1f7dd81825a447e9f4e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RemMarkerArray </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the marker from the set of handles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>set of handles </td></tr>
    <tr><td class="paramname">n</td><td>number of handles </td></tr>
    <tr><td class="paramname">m</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#aa758ff129bf79eff3c446946e276006c" title="Remove the marker from the element. ">Mesh::RemMarker</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5cb95f1e8d6b7987496fc8276c86cf3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::RemoveGhostElements </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete some ghost cells provided in array. </p>
<p>Non-ghost elements will also be deleted.</p>
<p>This algorithm will properly communicate between processors so that parallel states of deleted elements properly updated on remote processors. Internally function invokes Destroy function, not Delete, which hides elements during modification state, currently it is not expected that any parallel algorithms will be performed between BeginModification and EndModification since modification may break parallel state though it is never checked whether the mesh is in the modification state, so you are free to experiment. This behavior may change in future.</p>
<p>Collective point-2-point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ghost</td><td>array of handles </td></tr>
    <tr><td class="paramname">num</td><td>number of handles </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>TODO<ol type="1">
<li>Currently request for deletion of elements of lower level then cell will be simply ignored, ensure in future that algorithm will properly rise deletion data from lower to upper adjacencies to delete all the upper adjacencies that depend on deleted lower adjacencies </li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="a60274817b98e76ec5a411f0c3df2a76b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::ResolveModification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is not yet implemented. </p>
<p>It should correctly resolve parallel state of newly created elements, provide them valid global identificators, resolve owners of the elements potentially optimized using information from BridgeTag and LayersTag May use ResolveShared function as basis but instead the whole mesh run the same algorithm for subset. </p>

</div>
</div>
<a class="anchor" id="ac12ba58210b79c61e64a74c389cd11f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::Save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>File</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acceptable file formats for writing. </p>
<ul>
<li>".vtk" - legacy vtk format for unstructured grid</li>
<li>".pvtk" - legacy parallel vtk format</li>
<li>".gmv" - format acceptable by general mesh viewer</li>
<li>".pmf" - internal parallel portable binary format, saves all features</li>
</ul>
<p>Remeber: .pmf stores all references to elements. If reference are broken due to mesh modification, saving or loading such a mesh may lead to seagfault. To automatically maintain correct references modify mesh using BeginModification, ApplyModification, EndModification</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">File</td><td>path to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e40d1712147e6dc39113d855882743e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetData </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy into inner data array of size elements from provided array begining from shift element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents data </td></tr>
    <tr><td class="paramname">shift</td><td>for which element to start to copy </td></tr>
    <tr><td class="paramname">size</td><td>how many elements to copy </td></tr>
    <tr><td class="paramname">data</td><td>user-provided array where data should be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ade9beb68c97be47897b50ce6e4dcb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetDataSize </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classINMOST_1_1Tag.html">Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the array for data of variable size. </p>
<p>If you try to change size of data of constant size then if size is different from current then in debug mode (NDEBUG not set) assertion will fail, in release mode nothing happens. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of element </td></tr>
    <tr><td class="paramname">tag</td><td>tag that represents the data </td></tr>
    <tr><td class="paramname">new_size</td><td>new size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04a2c4cb85d29a3f8bae803b013a52c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetDimensions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set number of dimensions for mesh. </p>
<p>It sets the size for number of internally stored coordinates. Size of the array returned by Node::Coords will match this number. When you change number of dimensions and there are nodes with bigger number of dimensions then first dim coordinates are copied and the rest are dropped. </p>
<dl class="section see"><dt>See Also</dt><dd>Node::Coords </dd></dl>

</div>
</div>
<a class="anchor" id="a8ef41098a12fe80cac6f45ee94ef892b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__INLINE void INMOST::Mesh::SetEpsilon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#a853346784b4a5822a7fac54d8f10f805">real</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set tolerance for coordinates comparison. </p>
<p>This tolerance is used in comparators when two meshes are merged during loading, in ResolveShared to check that nodes on different processors match and in UnpackElementsData </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>small real value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07c75e9dee2c400225a6095e45489ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetFileOption </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set file option. </p>
<p>Current availible file options:</p>
<ul>
<li>"VTK_GRID_DIMS" - set "2" for two-dimensional vtk grids, "3" for three-dimensional vtk grids</li>
<li>"VERBOSITY" - set "2" for progress messages, "1" for reports, "0" for silence</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>TODO: introduce "SET_TAGS_LOAD", "SET_TAGS_SAVE" to explicitly provide set of tags to write or "SKIP_TAGS_LOAD", "SKIP_TAGS_SAVE" tags to skip </dd></dl>

</div>
</div>
<a class="anchor" id="ab0eb79ff655477197ce21dedae4712d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetMarker </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a marker on the element represented by handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">n</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84ff5329978e77876ca6b1b3ed9b5c39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetMarkerArray </td>
          <td>(</td>
          <td class="paramtype">const HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a marker on the set of handles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>set of handles </td></tr>
    <tr><td class="paramname">n</td><td>number of handles </td></tr>
    <tr><td class="paramname">m</td><td>stores byte number and byte bit mask that represent marker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#ab0eb79ff655477197ce21dedae4712d4" title="Set a marker on the element represented by handle. ">Mesh::SetMarker</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aadcd74b16a7a86db78d2cf5bb814f5a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetMarkerSpace </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae429556af77094077d212e0ac23c8cfc">bulk</a>&#160;</td>
          <td class="paramname"><em>source</em>[MarkerFields]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite the bytes that store markers on the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>element handle </td></tr>
    <tr><td class="paramname">source</td><td>storage to get data from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e45b137719114d78119bfe487be259f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetParallelFileStrategy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This strategy correspond only to internal ".pmf" mesh format. </p>
<p>There are two availible strategies for ".pmf" files loading and saving:</p>
<p>strategy = 0</p>
<ul>
<li>on save<ol type="1">
<li>every processor gather local data to some buffer</li>
<li>MPI_Gather to obtain sizes of data among processors</li>
<li>MPI_Gatherv to obtain the whole data on zeros processor</li>
<li>the first processor writes all the data to disk by std::fstream</li>
</ol>
</li>
<li>on load<ol type="1">
<li>first processors reads the whole file by std::fstream</li>
<li>MPI_Scatter distributes block sizes among processors</li>
<li>MPI_Scatterv distributes blocks among processors</li>
<li>Each processor parses it's block</li>
</ol>
</li>
</ul>
<p>This strategy requires one processor to hold all the data, which is quite bad for large files. New strategy may be created from this one in future when each processors consequently obtain access to the file using std::fstream and writes the data.</p>
<p>strategy = 1</p>
<ul>
<li>on save it will perform:<ol type="1">
<li>MPI_Gather to obtain sizes of data among processors on zeroth processor</li>
<li>MPI_File_open to get parallel handle for the file</li>
<li>MPI_File_write_shared called by processor with zeroth rank to write header</li>
<li>MPI_File_write_ordered to write contents of individual data</li>
<li>MPI_File_close to close parallel file handle</li>
</ol>
</li>
<li><p class="startli">on load it will perform</p>
<ol type="1">
<li>MPI_File_open to open the file in parallel</li>
<li>MPI_File_read_shared to get contents of header on zeroth processor</li>
<li>MPI_Scatter to distribute block sizes among processors</li>
<li>MPI_File_read_ordered to obtain contents</li>
<li>MPI_File_close to close parallel file handle</li>
</ol>
<p class="startli">Availible only when USE_MPI_P2P is set because it rely on MPI-2 api that begins with MPI_File_xxx some MPI-1 standards contain this api as extension.</p>
</li>
</ul>
<p>The strategy 1 appeared to be considerably slower on INM cluster then strategy 0, this may happen due to lack of read-write devices that able to work in parallel. On IBM Bluegene/p strategy 1 was not working due to same old problem with shared file pointers in their MPI realization </p>

</div>
</div>
<a class="anchor" id="adc92ee8e1fc34b3f3a41f2a1984ab6f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetParallelStrategy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parallel strategy for inner communications. </p>
<p>There are three possible scenaries in parallel communication associated in accordance to enum Prepare structre:</p>
<ol type="1">
<li>The communicating processors and sizes of the messages are known apriori</li>
<li>UnknownSize: Communicating processors are known but sizes are unknown</li>
<li>unknownSource: Communicationg processors are unknown</li>
</ol>
<p>Currently with UnknownSize it will run following algorithm none for strategy 0, following for strategies 1 and 2:</p>
<ol type="1">
<li>Post asynchronous receive with MPI_Irecv of size of buffer to be sent</li>
<li>Post asynchronous send with MPI_Isend for required corresponding receive buffer size</li>
<li>Wait for all asynchronous operations by MPI_Waitall</li>
</ol>
<p>With UnknownSource there are two options depending from the USE_MPI_P2P define. If USE_MPI_P2P is defined then MPI-2 api operations will be used</p>
<ol type="1">
<li>MPI_Win_fence to start operations</li>
<li>MPI_Put from specially allocated memory location to remote processor of array size is performed</li>
<li>MPI_Win_fence to stop operations</li>
</ol>
<p>if USE_MPI_P2P not set then MPI-1 api will be used</p>
<ol type="1">
<li>MPI_Allgather for number of processors to which current processor wants to send data</li>
<li>MPI_Allgatherv for sizes and destinations for each processors</li>
</ol>
<p>Initially it was intended to mainly use MPI-2 functionality for both scenarios but it was realized that there is no availible hardware on which MPI-2 functionalty performs match better then MPI-1 counterparts, especially in the case of UnknownSize. Probably this happens due to lack of support of RDMA operations. If you believe it will be better to use MPI-2 in both cases you are free to uncomment definition of PREFFER_MPI_P2P in <a class="el" href="inmost__common_8h_source.html">inmost_common.h</a> then MPI-2 will be used in both scenaries. These algorthms above are implemented in Mesh::ExchangeBufferInner.</p>
<p>After first problem was resolved following strategies are availible for main communication: strategy = 0</p>
<ol type="1">
<li>Asyncronous send of data by MPI_Isend;</li>
<li>Check incoming messages by MPI_Probe;</li>
<li>Check incoming message size by MPI_Get_size;</li>
<li>Allocation of buffers of required size;</li>
<li>Asynchronous receive of data</li>
<li>MPI_Waitsome to copy received results to buffers</li>
</ol>
<p>This strategy shows to be the fastest on mac with intel core 2 duo it appears to be independend on apriori knowledge of sizes of incoming messages and skips the step of determining sizes in all the cases but still it requires establishing knowledge of communicating processors Asynchronous sending and receiving may be performed by breaking the steps 1) and 2-5) but should be considered bad since it will be performed without appropriate receive buffers posted for sends, as a result messages will stuck in network pipeline and would be repeatedly rejected resulting in bad networking performance especially if processors have small memory. As a result non-asynchronous communication is realized with this stategy breaking steps 1-5) and 6) when you as for asynchronous communication startegy = 1</p>
<ol type="1">
<li>Post asynchronous receive of data by MPI_Irecv</li>
<li>Post asynchronous send of data by MPI_Isend</li>
<li>MPI_Waitsome for any received data</li>
</ol>
<p>True asynchronous behavior is reproduced by breaking 1-2) and 3) strategy = 2</p>
<ol type="1">
<li>Post asynchronous receive of data by MPI_Irecv</li>
<li>Set MPI_Barrier to ensure that all the receives were properly set by the time</li>
</ol>
<ol type="1">
<li>Perform direct send of data by MPI_Irsend</li>
<li>MPI_Waitsome for any received data</li>
</ol>
<p>For asynchronous communication algorithm is broken into 1-3) and 4) which is fairly asynchronous. The only provisional benefit it may have on machines with small memory since it should bypass any allocation of buffers for sent and received data by MPI and probably not perform any randezvous communication to ensure data allocation. But MPI_Barrier looks like elephant here.</p>
<p>Algorithms above are implemented in Mesh::ExchangeBuffersInner </p>
<dl class="section see"><dt>See Also</dt><dd>Mesh::PrepareReceiveInner </dd>
<dd>
Mesh::ExchangeBuffersInner </dd></dl>

</div>
</div>
<a class="anchor" id="a666201ee66a5a0f871d17781055b06ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SetStatus </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element::Status&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parallel status of the element. </p>
<p>If mesh is in Serial state then call will fire asserts in debug mode and segfault in relese mode.</p>
<p>Parallel status controls how exchange of data between elements will be performed, it is expected that number of elements and copies of elements do match between processors. This kind of check is never performed and if you fail to setup statuses correctly, you may end up with data being copied to incorrect elements. If you modify statuses on your own don't forget to call RecomputeParallelStorage, otherwise exchange will be performed by old status guidelines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
    <tr><td class="paramname">s</td><td>new status of the element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bfe7b75e432280922bfa7293743115c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool INMOST::Mesh::Show </td>
          <td>(</td>
          <td class="paramtype">HandleType&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Show element from mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>handle of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true then element was recovered </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classINMOST_1_1Mesh.html#a2b3eaaadcd233cf11deba24d1fd64ad1" title="Hide element from mesh. ">Mesh::Hide</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f8cfa72de874bd9a17fb0067ac8d515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SortByGlobalID </td>
          <td>(</td>
          <td class="paramtype">HandleType *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classINMOST_1_1Storage.html#ae333dfced6fa9cfde0c8e7dcf1b0cc2b">enumerator</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>TODO 53 check that putting global ids to array will be faster </dd></dl>

</div>
</div>
<a class="anchor" id="a9c3acf2a90e25699a64e1f7b4125eaf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ElementType INMOST::Mesh::SynchronizeElementType </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>etype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize bitwise mask of element types between processors. </p>
<p>Collective operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">etype</td><td>bitwise type mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitwise result among processors </dd></dl>

</div>
</div>
<a class="anchor" id="a8c7a825072f54b260caa0e8da8877647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void INMOST::Mesh::SynchronizeMarker </td>
          <td>(</td>
          <td class="paramtype">MarkerType&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SyncBitOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Syncronize marker on elements between processors using provided operation. </p>
<p>Depending on requested operation following action is performed:</p>
<ul>
<li>SYNC_BIT_SET - value on ghost elements is set by value on corresponding shared processors;</li>
<li>SYNC_BIT_OR - bitwise OR between values in ghosted and shared elements;</li>
<li>SYNC_BIT_AND - bitwise AND between values in ghosted and shared elements;</li>
<li>SYNC_BIT_XOR - bitwise XOR between values in ghosted and shared elements. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">marker</td><td>marker to be synchronized </td></tr>
    <tr><td class="paramname">mask</td><td>bitwise or type mask </td></tr>
    <tr><td class="paramname">op</td><td>operation, one of SYNC_BIT_SET, SYNC_BIT_OR, SYNC_BIT_XOR, SYNC_BIT_AND </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a72ee27b1b485c40e272f8018aa5ca0a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Tag.html">Tag</a> INMOST::Mesh::TopologyErrorTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will return tag by which you can retrieve error mark to any element on which topogy check failed. </p>
<p>As this is sparse tag you can check presence of error by <a class="el" href="classINMOST_1_1Storage.html#ab94105e63f94f9799ff9a58280d0bf63" title="Check if any data is associated with Tag. ">Element::HaveData</a> or <a class="el" href="classINMOST_1_1Mesh.html#a14fe30c96eba52f03de5780503116af1" title="Check whether data is present on given element. ">Mesh::HaveData</a> check. This tag will be valid only if you pass MARK_ON_ERROR to <a class="el" href="classINMOST_1_1Mesh.html#afad6ccd8132d0aed639ef18772def9ab" title="Retrieve currently set topology checks. ">Mesh::GetTopologyCheck</a> and will be deleted if you pass MARK_ON_ERROR to <a class="el" href="classINMOST_1_1Mesh.html#a374a56ae3bdae9e54030c72538836c09" title="Remove topology checks. ">Mesh::RemTopologyCheck</a> </p>

</div>
</div>
<a class="anchor" id="acc118e878e2cce11985e7384f18700fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classINMOST_1_1Storage.html#aec96942bc647417a801e2895b45964d2">integer</a> INMOST::Mesh::TotalNumberOf </td>
          <td>(</td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum of all physical elements, it excludes ghosted copies. </p>
<p>To compute total number including ghosted copies run Integrate(NumberOf(mask))</p>
<p>Collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>bitwise mask of element types, example: NODE | CELL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of elements </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>Mesh::NumberOf </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="inmost__mesh_8h_source.html">inmost_mesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 6 2015 10:40:46 for INMOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
